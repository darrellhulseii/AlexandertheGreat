<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Joan of Arc: Divine Warriors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=UnifrakturCook:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'MedievalSharp', cursive;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(184, 134, 11, 0.95));
            padding: 12px 18px;
            border: 3px solid #FFD700;
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), inset 0 0 15px rgba(0, 0, 0, 0.4);
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            font-size: 13px;
        }
        
        #hud h2 {
            font-family: 'UnifrakturCook', cursive;
            font-size: 22px;
            margin-bottom: 8px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        .stat {
            margin: 6px 0;
            font-size: 13px;
        }
        
        .bar-container {
            width: 160px;
            height: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            margin-top: 4px;
            position: relative;
            overflow: hidden;
            border-radius: 3px;
        }
        
        .bar {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #healthBar {
            background: linear-gradient(90deg, #8B0000, #DC143C);
            box-shadow: 0 0 10px #DC143C;
        }
        
        #specialBar {
            background: linear-gradient(90deg, #0000CD, #4169E1);
            box-shadow: 0 0 10px #4169E1;
        }
        
        .mobile-control {
            position: absolute;
            pointer-events: all;
            touch-action: none;
        }
        
        #joystickContainer {
            bottom: 25px;
            left: 25px;
            width: 140px;
            height: 140px;
        }
        
        #joystickBase {
            width: 140px;
            height: 140px;
            background: radial-gradient(circle, rgba(50, 50, 50, 0.85), rgba(20, 20, 20, 0.95));
            border: 4px solid rgba(255, 215, 0, 0.7);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.9), inset 0 0 25px rgba(255, 215, 0, 0.4);
        }
        
        #joystickStick {
            width: 65px;
            height: 65px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            border: 3px solid #FFD700;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6), 0 0 25px rgba(255, 215, 0, 0.5);
            transition: all 0.08s ease;
        }
        
        #attackButtons {
            bottom: 25px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        
        .attack-button {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            border: 4px solid #FFD700;
            font-family: 'MedievalSharp', cursive;
            font-size: 13px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.7), 0 0 35px rgba(255, 215, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.1s;
            touch-action: none;
        }
        
        #attackButton {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.95), rgba(139, 0, 0, 0.95));
        }
        
        #specialButton {
            background: radial-gradient(circle, rgba(65, 105, 225, 0.95), rgba(0, 0, 139, 0.95));
        }
        
        #prayButton {
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            width: 65px;
            height: 65px;
            font-size: 11px;
        }
        
        .attack-button:active {
            transform: scale(0.92);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.9), 0 0 18px rgba(255, 215, 0, 0.7);
        }
        
        #comboCounter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 56px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            opacity: 0;
            transition: opacity 0.3s;
            font-family: 'UnifrakturCook', cursive;
            pointer-events: none;
        }
        
        #comboCounter.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        #startScreen, #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        
        #startScreen h1 {
            font-family: 'UnifrakturCook', cursive;
            font-size: 52px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            margin-bottom: 25px;
            animation: glow 2s ease-in-out infinite;
        }
        
        #startButton {
            font-family: 'MedievalSharp', cursive;
            font-size: 26px;
            padding: 18px 50px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 12px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 35px rgba(255, 215, 0, 0.6);
            transition: all 0.3s;
        }
        
        #startButton:active {
            transform: scale(1.08);
        }
        
        .mode-button {
            font-family: 'MedievalSharp', cursive;
            font-size: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 12px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 35px rgba(255, 215, 0, 0.6);
            transition: all 0.3s;
            width: 400px;
            line-height: 1.6;
        }
        
        .mode-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 45px rgba(255, 215, 0, 0.8);
        }
        
        .mode-button:active {
            transform: scale(1.08);
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 25px #FFD700; }
            50% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 45px #FFD700; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #fpsCounter {
            position: absolute;
            top: 12px;
            right: 12px;
            color: #FFD700;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            border: 2px solid #FFD700;
            font-weight: bold;
        }
        
        #victoryMessage {
            font-family: 'UnifrakturCook', cursive;
            font-size: 48px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            text-align: center;
            line-height: 1.5;
            animation: glow 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>JOAN OF ARC</h1>
        <h3 style="color: #FFD700; font-size: 28px; margin-bottom: 20px;">⚔️ Divine Warriors ⚔️</h3>
        
        <div style="margin-bottom: 35px;">
            <h4 style="color: #FFD700; font-size: 22px; margin-bottom: 15px;">SELECT MODE:</h4>
            <button id="joanModeButton" class="mode-button" style="margin-bottom: 15px;">
                JOAN OF ARC MODE<br>
                <span style="font-size: 14px; font-family: Arial;">Lead Christian forces against invaders</span>
            </button>
            <button id="alexanderModeButton" class="mode-button">
                ALEXANDER THE GREAT MODE<br>
                <span style="font-size: 14px; font-family: Arial;">Conquer with the legendary Macedonian king</span>
            </button>
        </div>
    </div>
    
    <div id="victoryScreen" class="hidden">
        <div id="victoryMessage">
            ALL PRAISE AND<br>ALL GLORY TO<br>JESUS CHRIST
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <h2>⚜️ JOAN OF ARC ⚜️</h2>
            <div class="stat">
                Health
                <div class="bar-container">
                    <div id="healthBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">
                Divine Power
                <div class="bar-container">
                    <div id="specialBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">Kills: <span id="killCount">0</span></div>
            <div class="stat">Leaders: <span id="leaderCount">0</span>/5</div>
            <div class="stat">Combo: <span id="comboHits">0</span></div>
        </div>
        
        <div id="fpsCounter">FPS: <span id="fpsValue">0</span></div>
        
        <div id="comboCounter">0 HIT COMBO!</div>
        
        <div id="joystickContainer" class="mobile-control">
            <div id="joystickBase">
                <div id="joystickStick"></div>
            </div>
        </div>
        
        <div id="attackButtons" class="mobile-control">
            <div id="attackButton" class="attack-button">ATTACK</div>
            <div id="specialButton" class="attack-button">SPECIAL</div>
            <div id="prayButton" class="attack-button">PRAY</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        'use strict';
        
        // Game State
        const gameState = {
            health: 100,
            maxHealth: 100,
            special: 100,
            maxSpecial: 100,
            kills: 0,
            combo: 0,
            comboTimer: null,
            comboHits: 0,
            allies: [],
            enemies: [],
            leaders: [],
            isAttacking: false,
            gameStarted: false,
            prayTarget: null,
            leadersDefeated: 0,
            totalLeaders: 5,
            gameWon: false,
            gameMode: 'joan' // 'joan' or 'alexander'
        };

        // Mobile Controls State
        const mobileControls = {
            joystick: { active: false, x: 0, y: 0 },
            moveVector: { x: 0, z: 0 }
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xb8c5d6);
        scene.fog = new THREE.Fog(0xb8c5d6, 60, 280);

        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 18, 28);
        camera.lookAt(0, 0, 0);

        // Lighting Setup
        const ambientLight = new THREE.AmbientLight(0xb8c5d6, 0.65);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.1);
        sunLight.position.set(65, 55, 45);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xb0c4de, 0.45);
        fillLight.position.set(-45, 35, -35);
        scene.add(fillLight);

        const hemiLight = new THREE.HemisphereLight(0xb8c5d6, 0x5a7a4a, 0.75);
        scene.add(hemiLight);

        // Green Grassy Field
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base grass color
            ctx.fillStyle = '#4a7d35';
            ctx.fillRect(0, 0, 512, 512);
            
            // Add grass blade variations
            for (let i = 0; i < 12000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const greenShade = 70 + Math.random() * 50;
                const grassType = Math.random();
                
                if (grassType < 0.7) {
                    // Light green grass
                    ctx.fillStyle = `rgba(${greenShade * 0.5}, ${greenShade}, ${greenShade * 0.4}, ${0.4 + Math.random() * 0.3})`;
                } else {
                    // Dark green grass
                    ctx.fillStyle = `rgba(${greenShade * 0.3}, ${greenShade * 0.8}, ${greenShade * 0.3}, ${0.5 + Math.random() * 0.3})`;
                }
                
                const size = Math.random() * 3;
                ctx.fillRect(x, y, size, size);
            }
            
            // Add some dirt patches for realism
            for (let i = 0; i < 400; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brownShade = 80 + Math.random() * 40;
                ctx.fillStyle = `rgba(${brownShade}, ${brownShade * 0.7}, ${brownShade * 0.5}, 0.2)`;
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);
            return texture;
        }

        const groundGeometry = new THREE.PlaneGeometry(250, 250, 80, 80);
        const grassTexture = createGrassTexture();
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            map: grassTexture,
            color: 0x4a7d35,
            shininess: 3
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        
        // Create rolling hills
        const positions = ground.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const z = positions.getZ(i);
            let y = Math.sin(x * 0.015) * Math.cos(z * 0.015) * 3;
            y += Math.sin(x * 0.03) * Math.cos(z * 0.03) * 1.5;
            y += (Math.random() - 0.5) * 0.5;
            positions.setY(i, y);
        }
        positions.needsUpdate = true;
        ground.geometry.computeVertexNormals();
        scene.add(ground);

        // Add 3D grass tufts
        const grassTuftMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x3a6b2a,
            side: THREE.DoubleSide,
            flatShading: true
        });
        
        for (let i = 0; i < 200; i++) {
            const tuft = new THREE.Group();
            
            for (let j = 0; j < 10; j++) {
                const bladeGeometry = new THREE.ConeGeometry(0.04, 0.35 + Math.random() * 0.25, 3);
                const blade = new THREE.Mesh(bladeGeometry, grassTuftMaterial);
                blade.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.17,
                    (Math.random() - 0.5) * 0.4
                );
                blade.rotation.z = (Math.random() - 0.5) * 0.25;
                blade.rotation.x = (Math.random() - 0.5) * 0.15;
                tuft.add(blade);
            }
            
            tuft.position.set(
                (Math.random() - 0.5) * 220,
                0,
                (Math.random() - 0.5) * 220
            );
            scene.add(tuft);
        }

        // Distant Castle
        const castle = new THREE.Group();
        
        const castleMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            flatShading: true
        });
        
        // Main keep
        const keepGeometry = new THREE.BoxGeometry(18, 30, 18);
        const keep = new THREE.Mesh(keepGeometry, castleMaterial);
        keep.position.y = 15;
        keep.castShadow = true;
        castle.add(keep);
        
        // Battlements
        for (let i = 0; i < 16; i++) {
            const merlonGeometry = new THREE.BoxGeometry(1.8, 2.5, 1.8);
            const merlon = new THREE.Mesh(merlonGeometry, castleMaterial);
            const angle = (i / 16) * Math.PI * 2;
            merlon.position.set(
                Math.cos(angle) * 9.5,
                31.5,
                Math.sin(angle) * 9.5
            );
            merlon.castShadow = true;
            castle.add(merlon);
        }
        
        // Corner towers
        const towerPositions = [
            [-12, 0, -12],
            [12, 0, -12],
            [-12, 0, 12],
            [12, 0, 12]
        ];
        
        towerPositions.forEach(function(pos) {
            const towerGeometry = new THREE.CylinderGeometry(3.5, 4, 24, 16);
            const tower = new THREE.Mesh(towerGeometry, castleMaterial);
            tower.position.set(pos[0], 12, pos[2]);
            tower.castShadow = true;
            castle.add(tower);
            
            const roofGeometry = new THREE.ConeGeometry(4.8, 7, 16);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2a2a });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(pos[0], 27.5, pos[2]);
            roof.castShadow = true;
            castle.add(roof);
            
            const spireGeometry = new THREE.ConeGeometry(0.4, 4, 6);
            const spireMaterial = new THREE.MeshPhongMaterial({ color: 0x8B7355 });
            const spire = new THREE.Mesh(spireGeometry, spireMaterial);
            spire.position.set(pos[0], 32, pos[2]);
            castle.add(spire);
            
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), spireMaterial);
            crossV.position.set(pos[0], 34.5, pos[2]);
            castle.add(crossV);
            
            const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.15, 0.15), spireMaterial);
            crossH.position.set(pos[0], 34.9, pos[2]);
            castle.add(crossH);
        });
        
        // Castle walls
        const wallGeometry = new THREE.BoxGeometry(30, 10, 2.5);
        const walls = [
            [0, 5, -15],
            [0, 5, 15],
            [-15, 5, 0],
            [15, 5, 0]
        ];
        
        walls.forEach(function(pos, idx) {
            const wall = new THREE.Mesh(wallGeometry, castleMaterial);
            wall.position.set(pos[0], pos[1], pos[2]);
            if (idx >= 2) wall.rotation.y = Math.PI / 2;
            wall.castShadow = true;
            wall.receiveShadow = true;
            castle.add(wall);
        });
        
        // Position castle far in distance
        castle.position.set(-150, 0, -120);
        castle.scale.set(1.5, 1.5, 1.5);
        scene.add(castle);

        // Create Joan of Arc
        function createJoan() {
            const joan = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4169E1,
                shininess: 100,
                specular: 0x6495ED
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.5;
            torso.castShadow = true;
            joan.add(torso);
            
            const chestGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1.2, 16);
            const goldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 120,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, goldMaterial);
            chest.position.y = 2.9;
            chest.castShadow = true;
            joan.add(chest);
            
            const shoulderGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            leftShoulder.position.set(-0.95, 3.4, 0);
            leftShoulder.castShadow = true;
            joan.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            rightShoulder.position.set(0.95, 3.4, 0);
            rightShoulder.castShadow = true;
            joan.add(rightShoulder);
            
            const legGeometry = new THREE.CylinderGeometry(0.26, 0.3, 1.6, 12);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.32, 0.5, 0);
            leftLeg.castShadow = true;
            joan.add(leftLeg);
            joan.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.32, 0.5, 0);
            rightLeg.castShadow = true;
            joan.add(rightLeg);
            joan.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.22, 0.25, 1.9, 12);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.95, 2.5, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            joan.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.95, 2.5, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            joan.add(rightArm);
            joan.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.55, 20, 20);
            const skinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD1A3,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 4.1;
            head.castShadow = true;
            joan.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.6, 18, 14, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 4.3;
            hair.castShadow = true;
            joan.add(hair);
            
            // Soft white glow around Joan (replacing halo)
            const glowGeometry = new THREE.SphereGeometry(1.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2.5;
            joan.add(glow);
            joan.glow = glow;
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.8, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 150,
                specular: 0xFFFFFF
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.4;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.15);
            const guard = new THREE.Mesh(guardGeometry, goldMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(1, 2.5, 0);
            swordGroup.rotation.z = -0.3;
            joan.add(swordGroup);
            joan.sword = swordGroup;
            
            const capeGeometry = new THREE.BoxGeometry(1.5, 2.2, 0.1);
            const capeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C,
                shininess: 15,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 2.2, -0.5);
            cape.castShadow = true;
            joan.add(cape);
            joan.cape = cape;
            
            const glowLight = new THREE.PointLight(0xFFD700, 0.5, 10);
            glowLight.position.y = 4;
            joan.add(glowLight);
            joan.glowLight = glowLight;
            
            joan.position.set(0, 0, 0);
            joan.health = gameState.maxHealth;
            joan.isPlayer = true;
            joan.walkCycle = 0;
            joan.direction = 0;
            
            return joan;
        }

        // Create Alexander the Great
        function createAlexander() {
            const alexander = new THREE.Group();
            
            // Bronze/gold Macedonian armor
            const torsoGeometry = new THREE.CylinderGeometry(0.65, 0.85, 2.1, 16);
            const macedonianArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xCD7F32, // Bronze
                shininess: 110,
                specular: 0xFFD700
            });
            const torso = new THREE.Mesh(torsoGeometry, macedonianArmorMaterial);
            torso.position.y = 2.55;
            torso.castShadow = true;
            alexander.add(torso);
            
            // Muscled cuirass (Greek breastplate)
            const cuirassGeometry = new THREE.CylinderGeometry(0.75, 0.85, 1.3, 16);
            const goldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                specular: 0xFFFFFF,
                emissive: 0x221100
            });
            const cuirass = new THREE.Mesh(cuirassGeometry, goldMaterial);
            cuirass.position.y = 2.95;
            cuirass.castShadow = true;
            alexander.add(cuirass);
            
            // Prominent Greek shoulder plates
            const shoulderGeometry = new THREE.SphereGeometry(0.45, 16, 16);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            leftShoulder.position.set(-1, 3.5, 0);
            leftShoulder.castShadow = true;
            alexander.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            rightShoulder.position.set(1, 3.5, 0);
            rightShoulder.castShadow = true;
            alexander.add(rightShoulder);
            
            // Pteruges (leather strips)
            const pterugesGeometry = new THREE.BoxGeometry(0.08, 0.6, 0.08);
            const pterugesMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            for (let i = 0; i < 12; i++) {
                const pteruge = new THREE.Mesh(pterugesGeometry, pterugesMaterial);
                const angle = (i / 12) * Math.PI * 2;
                pteruge.position.set(
                    Math.sin(angle) * 0.7,
                    1.8,
                    Math.cos(angle) * 0.7
                );
                pteruge.castShadow = true;
                alexander.add(pteruge);
            }
            
            const legGeometry = new THREE.CylinderGeometry(0.28, 0.32, 1.7, 14);
            const leftLeg = new THREE.Mesh(legGeometry, macedonianArmorMaterial);
            leftLeg.position.set(-0.34, 0.52, 0);
            leftLeg.castShadow = true;
            alexander.add(leftLeg);
            alexander.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, macedonianArmorMaterial);
            rightLeg.position.set(0.34, 0.52, 0);
            rightLeg.castShadow = true;
            alexander.add(rightLeg);
            alexander.rightLeg = rightLeg;
            
            // Bronze greaves
            const greaveGeometry = new THREE.CylinderGeometry(0.3, 0.28, 0.8, 14);
            const leftGreave = new THREE.Mesh(greaveGeometry, goldMaterial);
            leftGreave.position.set(-0.34, 0.4, 0.18);
            leftGreave.castShadow = true;
            alexander.add(leftGreave);
            
            const rightGreave = new THREE.Mesh(greaveGeometry, goldMaterial);
            rightGreave.position.set(0.34, 0.4, 0.18);
            rightGreave.castShadow = true;
            alexander.add(rightGreave);
            
            const armGeometry = new THREE.CylinderGeometry(0.24, 0.27, 2, 14);
            const leftArm = new THREE.Mesh(armGeometry, macedonianArmorMaterial);
            leftArm.position.set(-1, 2.55, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            alexander.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, macedonianArmorMaterial);
            rightArm.position.set(1, 2.55, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            alexander.add(rightArm);
            alexander.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.58, 20, 20);
            const macedonianSkinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD1A3,
                shininess: 35
            });
            const head = new THREE.Mesh(headGeometry, macedonianSkinMaterial);
            head.position.y = 4.2;
            head.castShadow = true;
            alexander.add(head);
            
            // Iconic lion helmet
            const helmetGeometry = new THREE.SphereGeometry(0.62, 18, 16, 0, Math.PI * 2, 0, Math.PI * 0.65);
            const lionHelmetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                emissive: 0x332200
            });
            const helmet = new THREE.Mesh(helmetGeometry, lionHelmetMaterial);
            helmet.position.y = 4.4;
            helmet.castShadow = true;
            alexander.add(helmet);
            
            // Helmet crest (plume)
            const crestGeometry = new THREE.BoxGeometry(0.12, 1.2, 0.4);
            const crestMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C,
                shininess: 20
            });
            const crest = new THREE.Mesh(crestGeometry, crestMaterial);
            crest.position.y = 5.2;
            crest.castShadow = true;
            alexander.add(crest);
            
            // Legendary xiphos (Greek sword)
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.14, 2.4, 0.05);
            const greekBladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 160,
                specular: 0xFFFFFF,
                emissive: 0x444444,
                emissiveIntensity: 0.2
            });
            const blade = new THREE.Mesh(bladeGeometry, greekBladeMaterial);
            blade.position.y = 1.2;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(0.85, 0.16, 0.16);
            const guard = new THREE.Mesh(guardGeometry, goldMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(1.05, 2.55, 0);
            swordGroup.rotation.z = -0.3;
            alexander.add(swordGroup);
            alexander.sword = swordGroup;
            
            // Purple Macedonian cloak
            const cloakGeometry = new THREE.BoxGeometry(1.6, 2.3, 0.1);
            const cloakMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x800080, // Royal purple
                shininess: 25,
                side: THREE.DoubleSide
            });
            const cloak = new THREE.Mesh(cloakGeometry, cloakMaterial);
            cloak.position.set(0, 2.3, -0.55);
            cloak.castShadow = true;
            alexander.add(cloak);
            alexander.cape = cloak;
            
            // Golden conquerer's aura
            const auraGeometry = new THREE.SphereGeometry(1.9, 16, 16);
            const auraMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.18,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.position.y = 2.5;
            alexander.add(aura);
            alexander.glow = aura;
            
            const glowLight = new THREE.PointLight(0xFFD700, 0.65, 12);
            glowLight.position.y = 4.2;
            alexander.add(glowLight);
            alexander.glowLight = glowLight;
            
            alexander.position.set(0, 0, 0);
            alexander.health = gameState.maxHealth;
            alexander.isPlayer = true;
            alexander.walkCycle = 0;
            alexander.direction = 0;
            
            return alexander;
        }

        function createEnemy() {
            const enemy = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.55, 0.75, 1.8, 14);
            const darkArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a0000,
                shininess: 60
            });
            const torso = new THREE.Mesh(torsoGeometry, darkArmorMaterial);
            torso.position.y = 2.3;
            torso.castShadow = true;
            enemy.add(torso);
            
            const legGeometry = new THREE.CylinderGeometry(0.24, 0.27, 1.5, 12);
            const leftLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            leftLeg.position.set(-0.3, 0.45, 0);
            leftLeg.castShadow = true;
            enemy.add(leftLeg);
            enemy.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            rightLeg.position.set(0.3, 0.45, 0);
            rightLeg.castShadow = true;
            enemy.add(rightLeg);
            enemy.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.22, 1.7, 12);
            const leftArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            leftArm.position.set(-0.85, 2.3, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            enemy.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            rightArm.position.set(0.85, 2.3, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            enemy.add(rightArm);
            enemy.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.47, 16, 16);
            const darkSkinMaterial = new THREE.MeshPhongMaterial({ color: 0x505050 });
            const head = new THREE.Mesh(headGeometry, darkSkinMaterial);
            head.position.y = 3.65;
            head.castShadow = true;
            enemy.add(head);
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.5, 0.04);
            const darkBladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 90
            });
            const blade = new THREE.Mesh(bladeGeometry, darkBladeMaterial);
            blade.position.y = 1.25;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            swordGroup.position.set(0.95, 2.3, 0);
            swordGroup.rotation.z = -0.3;
            enemy.add(swordGroup);
            enemy.sword = swordGroup;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 20;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            enemy.health = 30;
            enemy.speed = 0.08 + Math.random() * 0.04;
            enemy.attackCooldown = 0;
            enemy.isEnemy = true;
            enemy.isLeader = false;
            enemy.walkCycle = 0;
            
            return enemy;
        }

        function createEnemyLeader() {
            const leader = new THREE.Group();
            
            // Larger imposing figure
            const torsoGeometry = new THREE.CylinderGeometry(0.7, 0.9, 2.2, 16);
            const leaderArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a0000,
                shininess: 80,
                emissive: 0x330000,
                emissiveIntensity: 0.3
            });
            const torso = new THREE.Mesh(torsoGeometry, leaderArmorMaterial);
            torso.position.y = 2.6;
            torso.castShadow = true;
            leader.add(torso);
            
            // Gold chest plate
            const chestGeometry = new THREE.CylinderGeometry(0.8, 0.9, 1.3, 16);
            const goldArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 120,
                specular: 0xFFFFFF,
                emissive: 0x332200
            });
            const chest = new THREE.Mesh(chestGeometry, goldArmorMaterial);
            chest.position.y = 3;
            chest.castShadow = true;
            leader.add(chest);
            
            const legGeometry = new THREE.CylinderGeometry(0.28, 0.32, 1.7, 14);
            const leftLeg = new THREE.Mesh(legGeometry, leaderArmorMaterial);
            leftLeg.position.set(-0.35, 0.55, 0);
            leftLeg.castShadow = true;
            leader.add(leftLeg);
            leader.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, leaderArmorMaterial);
            rightLeg.position.set(0.35, 0.55, 0);
            rightLeg.castShadow = true;
            leader.add(rightLeg);
            leader.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.24, 0.27, 2, 14);
            const leftArm = new THREE.Mesh(armGeometry, leaderArmorMaterial);
            leftArm.position.set(-1, 2.6, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            leader.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, leaderArmorMaterial);
            rightArm.position.set(1, 2.6, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            leader.add(rightArm);
            leader.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.55, 18, 18);
            const leaderSkinMaterial = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
            const head = new THREE.Mesh(headGeometry, leaderSkinMaterial);
            head.position.y = 4.2;
            head.castShadow = true;
            leader.add(head);
            
            // Evil crown
            const crownGeometry = new THREE.CylinderGeometry(0.58, 0.5, 0.6, 12);
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                emissive: 0x332200
            });
            const crown = new THREE.Mesh(crownGeometry, crownMaterial);
            crown.position.y = 4.75;
            crown.castShadow = true;
            leader.add(crown);
            
            // Crown spikes
            for (let i = 0; i < 8; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.08, 0.5, 6);
                const spike = new THREE.Mesh(spikeGeometry, crownMaterial);
                const angle = (i / 8) * Math.PI * 2;
                spike.position.set(
                    Math.cos(angle) * 0.48,
                    5.15,
                    Math.sin(angle) * 0.48
                );
                leader.add(spike);
            }
            
            // Large menacing sword
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.18, 3.5, 0.06);
            const leaderBladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFF0000,
                shininess: 110,
                emissive: 0x660000,
                emissiveIntensity: 0.4
            });
            const blade = new THREE.Mesh(bladeGeometry, leaderBladeMaterial);
            blade.position.y = 1.75;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(1, 0.18, 0.18);
            const guard = new THREE.Mesh(guardGeometry, goldArmorMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(1.1, 2.6, 0);
            swordGroup.rotation.z = -0.3;
            leader.add(swordGroup);
            leader.sword = swordGroup;
            
            // Red menacing aura
            const auraGeometry = new THREE.RingGeometry(2.5, 3.5, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.1;
            leader.add(aura);
            leader.aura = aura;
            
            const spawnAngle = Math.random() * Math.PI * 2;
            const spawnDistance = 40 + Math.random() * 30;
            leader.position.set(
                Math.cos(spawnAngle) * spawnDistance,
                0,
                Math.sin(spawnAngle) * spawnDistance
            );
            
            leader.health = 200;
            leader.maxHealth = 200;
            leader.speed = 0.12;
            leader.attackCooldown = 0;
            leader.isEnemy = true;
            leader.isLeader = true;
            leader.walkCycle = 0;
            
            return leader;
        }

        function createAlly() {
            const ally = new THREE.Group();
            
            // Full plate armor torso
            const torsoGeometry = new THREE.CylinderGeometry(0.58, 0.78, 1.9, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B8B8B,
                shininess: 95,
                specular: 0xCCCCCC
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.4;
            torso.castShadow = true;
            ally.add(torso);
            
            // Chest plate with cross emblem
            const chestGeometry = new THREE.CylinderGeometry(0.68, 0.78, 1.1, 16);
            const plateArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xA9A9A9,
                shininess: 110,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, plateArmorMaterial);
            chest.position.y = 2.7;
            chest.castShadow = true;
            ally.add(chest);
            
            // Red cross emblem on chest
            const crossVGeometry = new THREE.BoxGeometry(0.08, 0.6, 0.12);
            const crossMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C,
                emissive: 0x330000
            });
            const crossV = new THREE.Mesh(crossVGeometry, crossMaterial);
            crossV.position.set(0, 2.7, 0.8);
            ally.add(crossV);
            
            const crossHGeometry = new THREE.BoxGeometry(0.08, 0.4, 0.12);
            const crossH = new THREE.Mesh(crossHGeometry, crossMaterial);
            crossH.position.set(0, 2.85, 0.8);
            crossH.rotation.z = Math.PI / 2;
            ally.add(crossH);
            
            // Shoulder pauldrons
            const shoulderGeometry = new THREE.SphereGeometry(0.35, 14, 14);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            leftShoulder.position.set(-0.88, 3.25, 0);
            leftShoulder.castShadow = true;
            ally.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            rightShoulder.position.set(0.88, 3.25, 0);
            rightShoulder.castShadow = true;
            ally.add(rightShoulder);
            
            // Waist armor
            const waistGeometry = new THREE.CylinderGeometry(0.48, 0.58, 0.45, 16);
            const waist = new THREE.Mesh(waistGeometry, armorMaterial);
            waist.position.y = 1.25;
            waist.castShadow = true;
            ally.add(waist);
            
            // Armored legs
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.28, 1.55, 14);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.31, 0.48, 0);
            leftLeg.castShadow = true;
            ally.add(leftLeg);
            ally.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.31, 0.48, 0);
            rightLeg.castShadow = true;
            ally.add(rightLeg);
            ally.rightLeg = rightLeg;
            
            // Knee guards
            const kneeGeometry = new THREE.SphereGeometry(0.2, 12, 12);
            const leftKnee = new THREE.Mesh(kneeGeometry, plateArmorMaterial);
            leftKnee.position.set(-0.31, 0.85, 0.18);
            leftKnee.castShadow = true;
            ally.add(leftKnee);
            
            const rightKnee = new THREE.Mesh(kneeGeometry, plateArmorMaterial);
            rightKnee.position.set(0.31, 0.85, 0.18);
            rightKnee.castShadow = true;
            ally.add(rightKnee);
            
            // Armored arms
            const armGeometry = new THREE.CylinderGeometry(0.21, 0.24, 1.75, 14);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.88, 2.4, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            ally.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.88, 2.4, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            ally.add(rightArm);
            ally.rightArm = rightArm;
            
            // Gauntlets
            const gauntletGeometry = new THREE.BoxGeometry(0.22, 0.38, 0.22);
            const leftGauntlet = new THREE.Mesh(gauntletGeometry, plateArmorMaterial);
            leftGauntlet.position.set(-1.08, 1.55, 0);
            leftGauntlet.castShadow = true;
            ally.add(leftGauntlet);
            
            const rightGauntlet = new THREE.Mesh(gauntletGeometry, plateArmorMaterial);
            rightGauntlet.position.set(1.08, 1.55, 0);
            rightGauntlet.castShadow = true;
            ally.add(rightGauntlet);
            
            // Head with helmet
            const headGeometry = new THREE.SphereGeometry(0.48, 16, 16);
            const skinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD1A3 });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.72;
            head.castShadow = true;
            ally.add(head);
            
            // Full helmet
            const helmetGeometry = new THREE.SphereGeometry(0.52, 16, 14, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const helmetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB0B0B0,
                shininess: 105
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 3.88;
            helmet.castShadow = true;
            ally.add(helmet);
            
            // Visor slit
            const visorGeometry = new THREE.BoxGeometry(0.55, 0.08, 0.08);
            const visorMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 3.72, 0.52);
            ally.add(visor);
            
            // Chainmail coif visible at neck
            const chainmailGeometry = new THREE.CylinderGeometry(0.35, 0.45, 0.35, 16);
            const chainmailMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x707070,
                shininess: 50
            });
            const chainmail = new THREE.Mesh(chainmailGeometry, chainmailMaterial);
            chainmail.position.y = 3.35;
            chainmail.castShadow = true;
            ally.add(chainmail);
            
            // Sword
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.11, 2.4, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xE8E8E8,
                shininess: 115
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.2;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(0.7, 0.11, 0.11);
            const guard = new THREE.Mesh(guardGeometry, armorMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(0.98, 2.4, 0);
            swordGroup.rotation.z = -0.3;
            ally.add(swordGroup);
            ally.sword = swordGroup;
            
            // Tabard/surcoat over armor
            const tabardGeometry = new THREE.BoxGeometry(0.85, 1.5, 0.08);
            const tabardMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });
            const tabard = new THREE.Mesh(tabardGeometry, tabardMaterial);
            tabard.position.set(0, 2.3, 0.82);
            tabard.castShadow = true;
            ally.add(tabard);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 5 + Math.random() * 3;
            ally.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            ally.targetEnemy = null;
            ally.attackCooldown = 0;
            ally.isAlly = true;
            ally.walkCycle = 0;
            ally.health = 80;
            
            return ally;
        }

        let player = null; // Will be created based on mode selection

        function initializePlayer(mode) {
            if (player) {
                scene.remove(player);
            }
            
            gameState.gameMode = mode;
            
            if (mode === 'joan') {
                player = createJoan();
                document.getElementById('hud').querySelector('h2').textContent = '⚜️ JOAN OF ARC ⚜️';
            } else if (mode === 'alexander') {
                player = createAlexander();
                document.getElementById('hud').querySelector('h2').textContent = '⚔️ ALEXANDER THE GREAT ⚔️';
            }
            
            scene.add(player);
            
            // Clear and recreate allies
            gameState.allies.forEach(function(ally) {
                scene.remove(ally);
            });
            gameState.allies = [];
            
            // Create 5 allied forces
            for (let i = 0; i < 5; i++) {
                const ally = createAlly();
                gameState.allies.push(ally);
                scene.add(ally);
            }
        }

        // Joystick Controls
        const joystickBase = document.getElementById('joystickBase');
        const joystickStick = document.getElementById('joystickStick');
        
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        
        joystickBase.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            joystickActive = true;
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
        }, { passive: false });
        
        joystickBase.addEventListener('touchmove', function(e) {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - joystickStartX;
            const deltaY = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 38;
            const clampedDistance = Math.min(distance, maxDistance);
            
            const angle = Math.atan2(deltaY, deltaX);
            const clampedX = Math.cos(angle) * clampedDistance;
            const clampedY = Math.sin(angle) * clampedDistance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;
            
            mobileControls.moveVector.x = clampedX / maxDistance;
            mobileControls.moveVector.z = clampedY / maxDistance;
        }, { passive: false });
        
        joystickBase.addEventListener('touchend', function(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            mobileControls.moveVector.x = 0;
            mobileControls.moveVector.z = 0;
        }, { passive: false });

        document.getElementById('attackButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (!gameState.isAttacking && gameState.gameStarted) {
                playerAttack();
            }
        }, { passive: false });
        
        document.getElementById('specialButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.special >= 50 && gameState.gameStarted) {
                specialAttack();
            }
        }, { passive: false });
        
        document.getElementById('prayButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.gameStarted) {
                prayForLeader();
            }
        }, { passive: false });

        function playerAttack() {
            gameState.isAttacking = true;
            
            const sword = player.sword;
            const originalRotation = sword.rotation.z;
            
            let swingProgress = 0;
            function animateSwing() {
                swingProgress += 0.15;
                if (swingProgress < 1) {
                    sword.rotation.z = originalRotation - Math.sin(swingProgress * Math.PI) * Math.PI / 2;
                    requestAnimationFrame(animateSwing);
                } else {
                    sword.rotation.z = originalRotation;
                    gameState.isAttacking = false;
                }
            }
            animateSwing();
            
            let hitSomething = false;
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 5) {
                    const damage = 25;
                    enemy.health -= damage;
                    hitSomething = true;
                    
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(2));
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
            
            if (hitSomething) {
                updateCombo();
            }
        }

        function specialAttack() {
            gameState.special -= 50;
            updateUI();
            
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 15) {
                    enemy.health -= 50;
                    
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(5));
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
        }

        function prayForLeader() {
            const flashDiv = document.createElement('div');
            flashDiv.style.position = 'fixed';
            flashDiv.style.top = '0';
            flashDiv.style.left = '0';
            flashDiv.style.width = '100%';
            flashDiv.style.height = '100%';
            flashDiv.style.background = 'rgba(255, 215, 0, 0.3)';
            flashDiv.style.pointerEvents = 'none';
            flashDiv.style.zIndex = '50';
            document.body.appendChild(flashDiv);
            
            setTimeout(function() {
                document.body.removeChild(flashDiv);
            }, 500);
        }

        function killEnemy(enemy) {
            scene.remove(enemy);
            gameState.enemies = gameState.enemies.filter(function(e) { return e !== enemy; });
            
            if (enemy.isLeader) {
                gameState.leaders = gameState.leaders.filter(function(l) { return l !== enemy; });
                gameState.leadersDefeated++;
                gameState.prayTarget = null;
                
                if (gameState.leadersDefeated >= gameState.totalLeaders) {
                    showVictory();
                }
            }
            
            gameState.kills++;
            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 10);
            updateUI();
        }
        
        function showVictory() {
            gameState.gameWon = true;
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('victoryScreen').classList.remove('hidden');
            
            const victoryMessage = document.getElementById('victoryMessage');
            if (gameState.gameMode === 'joan') {
                victoryMessage.innerHTML = 'ALL PRAISE AND<br>ALL GLORY TO<br>JESUS CHRIST';
            } else if (gameState.gameMode === 'alexander') {
                victoryMessage.innerHTML = 'VICTORY!<br>THE WORLD<br>IS CONQUERED!';
            }
        }

        function updateCombo() {
            gameState.combo++;
            gameState.comboHits++;
            
            if (gameState.comboTimer) {
                clearTimeout(gameState.comboTimer);
            }
            
            const comboElement = document.getElementById('comboCounter');
            comboElement.textContent = gameState.combo + ' HIT COMBO!';
            comboElement.classList.add('show');
            
            gameState.comboTimer = setTimeout(function() {
                gameState.combo = 0;
                comboElement.classList.remove('show');
            }, 2000);
        }

        function updateUI() {
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('specialBar').style.width = (gameState.special / gameState.maxSpecial * 100) + '%';
            document.getElementById('killCount').textContent = gameState.kills;
            document.getElementById('leaderCount').textContent = gameState.leadersDefeated;
            document.getElementById('comboHits').textContent = gameState.comboHits;
        }

        function updateEnemy(enemy) {
            const playerDistance = enemy.position.distanceTo(player.position);
            
            if (playerDistance > 3) {
                const direction = new THREE.Vector3()
                    .subVectors(player.position, enemy.position)
                    .normalize();
                enemy.position.add(direction.multiplyScalar(enemy.speed));
                enemy.lookAt(player.position);
                
                enemy.walkCycle += 0.14;
                const legSwing = Math.sin(enemy.walkCycle) * 0.5;
                enemy.leftLeg.rotation.x = legSwing;
                enemy.rightLeg.rotation.x = -legSwing;
            } else {
                enemy.lookAt(player.position);
                
                if (enemy.attackCooldown <= 0) {
                    enemy.attackCooldown = 90;
                    gameState.health -= 5;
                    updateUI();
                    
                    if (gameState.health <= 0) {
                        alert('Defeated! You killed ' + gameState.kills + ' enemies.');
                        location.reload();
                    }
                }
            }
            
            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
            }
        }

        function updateAlly(ally) {
            if (!ally.targetEnemy || ally.targetEnemy.health <= 0) {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                gameState.enemies.forEach(function(enemy) {
                    const distance = ally.position.distanceTo(enemy.position);
                    if (distance < nearestDistance && distance < 35) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                ally.targetEnemy = nearestEnemy;
            }
            
            if (ally.targetEnemy) {
                const direction = new THREE.Vector3()
                    .subVectors(ally.targetEnemy.position, ally.position);
                const distance = direction.length();
                
                if (distance > 3.5) {
                    direction.normalize();
                    ally.position.add(direction.multiplyScalar(0.11));
                    ally.lookAt(ally.targetEnemy.position);
                    
                    ally.walkCycle += 0.16;
                    const legSwing = Math.sin(ally.walkCycle) * 0.52;
                    ally.leftLeg.rotation.x = legSwing;
                    ally.rightLeg.rotation.x = -legSwing;
                    ally.rightArm.rotation.x = Math.sin(ally.walkCycle) * 0.33;
                } else {
                    ally.lookAt(ally.targetEnemy.position);
                    
                    ally.leftLeg.rotation.x *= 0.9;
                    ally.rightLeg.rotation.x *= 0.9;
                    ally.rightArm.rotation.x *= 0.9;
                    
                    if (ally.attackCooldown <= 0) {
                        ally.attackCooldown = 65;
                        ally.targetEnemy.health -= 18;
                        
                        if (ally.sword) {
                            ally.sword.rotation.z = -Math.PI / 3;
                            setTimeout(function() {
                                if (ally.sword) ally.sword.rotation.z = -0.3;
                            }, 220);
                        }
                        
                        if (ally.targetEnemy.health <= 0) {
                            killEnemy(ally.targetEnemy);
                            ally.targetEnemy = null;
                        }
                    }
                }
            }
            
            if (ally.attackCooldown > 0) {
                ally.attackCooldown--;
            }
        }

        function spawnEnemies() {
            if (gameState.enemies.length < 20) {
                const enemy = createEnemy();
                gameState.enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function spawnLeader() {
            if (gameState.leaders.length < 2 && gameState.leadersDefeated < gameState.totalLeaders) {
                const leader = createEnemyLeader();
                gameState.leaders.push(leader);
                gameState.enemies.push(leader);
                scene.add(leader);
            }
        }

        let lastTime = Date.now();
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let spawnTimer = 0;
        let leaderSpawnTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameState.gameStarted) {
                renderer.render(scene, camera);
                return;
            }
            
            const currentTime = Date.now();
            lastTime = currentTime;

            frameCount++;
            if (currentTime - lastFPSUpdate >= 1000) {
                document.getElementById('fpsValue').textContent = frameCount;
                frameCount = 0;
                lastFPSUpdate = currentTime;
            }

            const moveSpeed = 0.22;
            let isMoving = false;
            
            if (joystickActive) {
                const joyX = mobileControls.moveVector.x;
                const joyZ = mobileControls.moveVector.z;
                
                if (Math.abs(joyX) > 0.1 || Math.abs(joyZ) > 0.1) {
                    isMoving = true;
                    
                    // Calculate 8-directional movement
                    const angle = Math.atan2(joyX, joyZ);
                    
                    // Determine direction (0-7 for 8 directions)
                    let direction = Math.round(angle / (Math.PI / 4));
                    if (direction < 0) direction += 8;
                    if (direction >= 8) direction = 0;
                    
                    // Calculate movement based on joystick input
                    const magnitude = Math.min(Math.sqrt(joyX * joyX + joyZ * joyZ), 1);
                    
                    // Move in the direction
                    player.position.x += Math.sin(angle) * moveSpeed * magnitude;
                    player.position.z += Math.cos(angle) * moveSpeed * magnitude;
                    
                    // Face the direction of movement
                    player.rotation.y = angle;
                    player.direction = direction;
                }
            }

            if (isMoving) {
                player.walkCycle += 0.18;
                
                const legSwing = Math.sin(player.walkCycle) * 0.6;
                player.leftLeg.rotation.x = legSwing;
                player.rightLeg.rotation.x = -legSwing;
                player.rightArm.rotation.x = Math.sin(player.walkCycle) * 0.4;
                
                const bodyBob = Math.abs(Math.sin(player.walkCycle)) * 0.15;
                player.position.y = bodyBob;
                
                player.cape.rotation.x = Math.sin(player.walkCycle * 0.5) * 0.12;
            } else {
                player.leftLeg.rotation.x *= 0.9;
                player.rightLeg.rotation.x *= 0.9;
                player.rightArm.rotation.x *= 0.9;
                player.position.y *= 0.9;
                player.cape.rotation.x *= 0.9;
                
                const breathe = Math.sin(currentTime * 0.001) * 0.02;
                player.position.y = breathe;
            }

            player.position.x = Math.max(-90, Math.min(90, player.position.x));
            player.position.z = Math.max(-90, Math.min(90, player.position.z));

            if (player.glow && player.glowLight) {
                player.glow.material.opacity = 0.12 + Math.sin(currentTime * 0.002) * 0.08;
                player.glowLight.intensity = 0.6 + Math.sin(currentTime * 0.003) * 0.4;
            }

            gameState.enemies.forEach(updateEnemy);
            gameState.allies.forEach(updateAlly);

            spawnTimer++;
            if (spawnTimer > 30) {
                spawnTimer = 0;
                spawnEnemies();
            }

            // Spawn leader every 30 seconds (5400 frames at 60fps)
            leaderSpawnTimer++;
            if (leaderSpawnTimer > 5400) {
                leaderSpawnTimer = 0;
                spawnLeader();
            }

            // Update leader aura animation
            gameState.leaders.forEach(function(leader) {
                if (leader.aura) {
                    leader.aura.rotation.z += 0.05;
                    leader.aura.material.opacity = 0.35 + Math.sin(currentTime * 0.005) * 0.15;
                }
            });

            // Update pray target indicator
            if (gameState.prayTarget && gameState.prayTarget.aura) {
                gameState.prayTarget.aura.material.opacity = 0.5 + Math.sin(currentTime * 0.008) * 0.2;
            }

            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 28;
            camera.lookAt(player.position);

            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 0.05);
            if (Math.random() < 0.01) {
                updateUI();
            }

            renderer.render(scene, camera);
        }

        document.getElementById('joanModeButton').addEventListener('click', function() {
            initializePlayer('joan');
            document.getElementById('startScreen').classList.add('hidden');
            gameState.gameStarted = true;
            animate();
            
            setTimeout(function() {
                spawnLeader();
            }, 3000);
        });
        
        document.getElementById('alexanderModeButton').addEventListener('click', function() {
            initializePlayer('alexander');
            document.getElementById('startScreen').classList.add('hidden');
            gameState.gameStarted = true;
            animate();
            
            setTimeout(function() {
                spawnLeader();
            }, 3000);
        });

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        renderer.render(scene, camera);
    </script>
</body>
</html>
