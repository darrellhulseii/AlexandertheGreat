<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Joan of Arc: Divine Warriors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=UnifrakturCook:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'MedievalSharp', cursive;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(184, 134, 11, 0.95));
            padding: 12px 18px;
            border: 3px solid #FFD700;
            border-radius: 8px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            font-size: 13px;
        }
        
        #hud h2 {
            font-family: 'UnifrakturCook', cursive;
            font-size: 22px;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .stat {
            margin: 6px 0;
            font-size: 13px;
        }
        
        .bar-container {
            width: 160px;
            height: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            margin-top: 4px;
            position: relative;
            overflow: hidden;
            border-radius: 3px;
        }
        
        .bar {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #healthBar {
            background: linear-gradient(90deg, #8B0000, #DC143C);
            box-shadow: 0 0 10px #DC143C;
        }
        
        #specialBar {
            background: linear-gradient(90deg, #0000CD, #4169E1);
            box-shadow: 0 0 10px #4169E1;
        }
        
        .mobile-control {
            position: absolute;
            pointer-events: all;
            touch-action: none;
        }
        
        #joystickContainer {
            bottom: 25px;
            left: 25px;
            width: 140px;
            height: 140px;
        }
        
        #joystickBase {
            width: 140px;
            height: 140px;
            background: radial-gradient(circle, rgba(50, 50, 50, 0.85), rgba(20, 20, 20, 0.95));
            border: 4px solid rgba(255, 215, 0, 0.7);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.9);
        }
        
        #joystickStick {
            width: 65px;
            height: 65px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            border: 3px solid #FFD700;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
            transition: all 0.08s ease;
        }
        
        #attackButtons {
            bottom: 25px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        
        .attack-button {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            border: 4px solid #FFD700;
            font-family: 'MedievalSharp', cursive;
            font-size: 13px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.1s;
            touch-action: none;
        }
        
        #attackButton {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.95), rgba(139, 0, 0, 0.95));
        }
        
        #specialButton {
            background: radial-gradient(circle, rgba(65, 105, 225, 0.95), rgba(0, 0, 139, 0.95));
        }
        
        #prayButton {
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            width: 65px;
            height: 65px;
            font-size: 11px;
        }
        
        .attack-button:active {
            transform: scale(0.92);
        }
        
        #comboCounter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 56px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            opacity: 0;
            transition: opacity 0.3s;
            font-family: 'UnifrakturCook', cursive;
            pointer-events: none;
        }
        
        #comboCounter.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        #modeSelection, #startScreen, #cutsceneScreen, #dialogueScreen, #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        
        #modeSelection h1 {
            font-family: 'UnifrakturCook', cursive;
            font-size: 52px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            margin-bottom: 50px;
            animation: glow 2s ease-in-out infinite;
        }
        
        .mode-button {
            font-family: 'MedievalSharp', cursive;
            font-size: 24px;
            padding: 18px 50px;
            margin: 15px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 12px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 35px rgba(255, 215, 0, 0.6);
            transition: all 0.3s;
        }
        
        .mode-button:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #DC143C, #8B0000);
        }
        
        .mode-button:active {
            transform: scale(0.98);
        }
        
        #cutsceneScreen {
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
        }
        
        #cutsceneContent {
            max-width: 900px;
            padding: 40px;
            text-align: center;
        }
        
        #cutsceneTitle {
            font-family: 'UnifrakturCook', cursive;
            font-size: 42px;
            color: #FFD700;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 #8B0000;
        }
        
        #cutsceneText {
            font-size: 20px;
            color: #E8E8E8;
            line-height: 1.8;
            margin-bottom: 40px;
            text-shadow: 1px 1px 2px #000;
        }
        
        #continueButton {
            font-family: 'MedievalSharp', cursive;
            font-size: 22px;
            padding: 15px 45px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        
        #dialogueScreen {
            background: linear-gradient(135deg, #2a2a3e, #1a1a2e);
        }
        
        #dialogueBox {
            max-width: 800px;
            padding: 35px;
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #FFD700;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.7);
        }
        
        #speakerName {
            font-family: 'UnifrakturCook', cursive;
            font-size: 32px;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #8B0000;
        }
        
        #dialogueText {
            font-size: 19px;
            color: #E8E8E8;
            line-height: 1.7;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px #000;
        }
        
        .dialogue-option {
            font-family: 'MedievalSharp', cursive;
            font-size: 17px;
            padding: 12px 30px;
            margin: 10px;
            background: linear-gradient(135deg, #4a4a5e, #2a2a3e);
            color: #FFD700;
            border: 3px solid #FFD700;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 1px 1px 3px #000;
            transition: all 0.2s;
        }
        
        .dialogue-option:hover {
            background: linear-gradient(135deg, #8B0000, #DC143C);
            transform: translateX(10px);
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 25px #FFD700; }
            50% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 45px #FFD700; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #fpsCounter {
            position: absolute;
            top: 12px;
            right: 12px;
            color: #FFD700;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            border: 2px solid #FFD700;
            font-weight: bold;
        }
        
        #questLog {
            position: absolute;
            top: 200px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border: 3px solid #FFD700;
            border-radius: 8px;
            max-width: 320px;
            color: #FFD700;
            text-shadow: 1px 1px 2px #000;
        }
        
        #questLog h3 {
            font-family: 'UnifrakturCook', cursive;
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #questObjective {
            font-size: 14px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="modeSelection">
        <h1>JOAN OF ARC</h1>
        <h3 style="color: #FFD700; font-size: 28px; margin-bottom: 35px;">‚öîÔ∏è Divine Warriors ‚öîÔ∏è</h3>
        <button class="mode-button" onclick="selectMode('story')">STORY MODE</button>
        <button class="mode-button" onclick="selectMode('alexander')">ALEXANDER THE GREAT</button>
        <button class="mode-button" onclick="selectMode('arcade')">ARCADE MODE</button>
    </div>
    
    <div id="cutsceneScreen" class="hidden">
        <div id="cutsceneContent">
            <h2 id="cutsceneTitle"></h2>
            <p id="cutsceneText"></p>
            <button id="continueButton" onclick="endCutscene()">CONTINUE</button>
        </div>
    </div>
    
    <div id="dialogueScreen" class="hidden">
        <div id="dialogueBox">
            <h2 id="speakerName"></h2>
            <p id="dialogueText"></p>
            <div id="dialogueOptions"></div>
        </div>
    </div>
    
    <div id="victoryScreen" class="hidden">
        <div style="text-align: center;">
            <h1 style="font-family: 'UnifrakturCook', cursive; font-size: 48px; color: #FFD700; text-shadow: 4px 4px 0 #8B0000; margin-bottom: 30px;">
                VICTORY!
            </h1>
            <p id="victoryMessage" style="font-size: 24px; color: #E8E8E8; margin-bottom: 30px;"></p>
            <button class="mode-button" onclick="location.reload()">RETURN TO MENU</button>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <h2 id="characterName">‚öúÔ∏è JOAN OF ARC ‚öúÔ∏è</h2>
            <div class="stat">
                Health
                <div class="bar-container">
                    <div id="healthBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">
                Divine Power
                <div class="bar-container">
                    <div id="specialBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">Kills: <span id="killCount">0</span></div>
            <div class="stat">Leaders: <span id="leaderCount">0</span>/<span id="totalLeaders">5</span></div>
            <div class="stat">Combo: <span id="comboHits">0</span></div>
        </div>
        
        <div id="questLog" class="hidden">
            <h3>üìú Quest</h3>
            <p id="questObjective"></p>
        </div>
        
        <div id="fpsCounter">FPS: <span id="fpsValue">0</span></div>
        
        <div id="comboCounter">0 HIT COMBO!</div>
        
        <div id="joystickContainer" class="mobile-control">
            <div id="joystickBase">
                <div id="joystickStick"></div>
            </div>
        </div>
        
        <div id="attackButtons" class="mobile-control">
            <div id="attackButton" class="attack-button">ATTACK</div>
            <div id="specialButton" class="attack-button">SPECIAL</div>
            <div id="prayButton" class="attack-button">PRAY</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        'use strict';
        
        // Story Data
        const storyChapters = [
            {
                title: "Chapter 1: The Calling - 1428",
                text: "At the age of 16, Joan of Arc hears divine voices calling her to save France from English invasion. She must convince the local garrison commander, Robert de Baudricourt, to grant her an escort to meet the Dauphin Charles.",
                location: "Vaucouleurs",
                dialogue: {
                    speaker: "Robert de Baudricourt",
                    text: "A peasant girl claiming to hear voices from God? This is madness! Why should I send you to the Dauphin?",
                    options: [
                        { text: "God has chosen me to save France from the English.", response: "quest" },
                        { text: "I can prove my divine mission through victory.", response: "quest" }
                    ]
                },
                quest: "Defeat 20 English soldiers to prove your divine calling",
                objective: { type: "kills", count: 20 },
                nextChapter: 1
            },
            {
                title: "Chapter 2: Journey to Chinon - 1429",
                text: "After proving herself, Joan travels 11 days through enemy territory to reach the Dauphin at Chinon. She must protect her small escort from English patrols and Burgundian raiders.",
                location: "Road to Chinon",
                dialogue: {
                    speaker: "Jean de Metz (Escort Knight)",
                    text: "The route ahead is dangerous. English patrols control this region. Are you certain God protects us?",
                    options: [
                        { text: "I have faith. We will reach Chinon safely.", response: "quest" },
                        { text: "Prepare for battle. We fight through if necessary.", response: "quest" }
                    ]
                },
                quest: "Defeat 3 English patrol leaders without losing any allies",
                objective: { type: "leaders", count: 3, protectAllies: true },
                nextChapter: 2
            },
            {
                title: "Chapter 3: The Siege of Orl√©ans - May 1429",
                text: "Joan arrives at Orl√©ans, which has been besieged by English forces for months. She must break the siege and liberate the city, turning the tide of the Hundred Years' War.",
                location: "Orl√©ans",
                dialogue: {
                    speaker: "Jean d'Orl√©ans (Duke Commander)",
                    text: "The English have held us for seven months. Their fortifications are strong. How can one girl change our fate?",
                    options: [
                        { text: "God is with us. We attack at dawn!", response: "quest" },
                        { text: "Faith and courage will break their siege.", response: "quest" }
                    ]
                },
                quest: "Defeat 5 English commanders and break the siege",
                objective: { type: "leaders", count: 5 },
                nextChapter: 3
            },
            {
                title: "Chapter 4: The March to Reims - Summer 1429",
                text: "After the victory at Orl√©ans, Joan leads the French army on a daring campaign to capture Reims, where French kings are traditionally crowned. Several cities must be liberated along the way.",
                location: "Loire Valley",
                dialogue: {
                    speaker: "The Dauphin Charles",
                    text: "Joan, you have brought us victory at Orl√©ans. Now we must secure Reims for my coronation. Can you clear the path?",
                    options: [
                        { text: "We march for Reims! No force can stop us!", response: "quest" },
                        { text: "Your Highness, God wills your coronation.", response: "quest" }
                    ]
                },
                quest: "Clear the route to Reims - Defeat 40 enemy soldiers",
                objective: { type: "kills", count: 40 },
                nextChapter: 4
            },
            {
                title: "Chapter 5: The Coronation - July 17, 1429",
                text: "Joan stands beside Charles VII as he is crowned King of France in Reims Cathedral. But the English still threaten Paris, and her mission is not yet complete.",
                location: "Reims Cathedral",
                dialogue: {
                    speaker: "King Charles VII",
                    text: "Joan, you have fulfilled your divine mission. France is reborn through your faith and courage. Will you continue to fight for us?",
                    options: [
                        { text: "I will fight until France is free, Your Majesty.", response: "quest" },
                        { text: "My sword is yours until victory is complete.", response: "quest" }
                    ]
                },
                quest: "Final battle - Defeat the English commanders at Paris",
                objective: { type: "leaders", count: 5 },
                nextChapter: -1
            }
        ];
        
        // Alexander the Great story
        const alexanderStory = {
            title: "Alexander the Great - 334 BC",
            text: "You are Alexander III of Macedon, known to history as Alexander the Great. Having inherited a powerful army from your father Philip II, you now embark on your legendary conquest of the Persian Empire. Lead your Macedonian phalanx to glory!",
            quest: "Conquer and defeat 50 Persian warriors and 8 commanders",
            objective: { type: "both", kills: 50, leaders: 8 }
        };
        
        // Audio Setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic = null;
        
        // Generate church organ background music (uncopyrighted procedural music)
        function createChurchMusic() {
            const duration = 60; // 60 seconds - full beautiful composition
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(2, duration * sampleRate, sampleRate);
            
            // Beautiful baroque-style chord progression inspired by Pachelbel's Canon
            // Each measure is 4 seconds for slow, reverent pacing
            const measures = [
                // Opening (0-16s) - Classic I-V-vi-iii-IV-I-IV-V progression
                { time: 0, chords: [261.63, 329.63, 392.00, 523.25] },    // C major - I
                { time: 4, chords: [392.00, 493.88, 587.33, 783.99] },    // G major - V
                { time: 8, chords: [220.00, 277.18, 329.63, 440.00] },    // A minor - vi
                { time: 12, chords: [164.81, 207.65, 246.94, 329.63] },   // E minor - iii
                
                // Development (16-32s)
                { time: 16, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 20, chords: [261.63, 329.63, 392.00, 523.25] },   // C major - I
                { time: 24, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 28, chords: [392.00, 493.88, 587.33, 783.99] },   // G major - V
                
                // Middle section (32-48s) - Rich modulation
                { time: 32, chords: [220.00, 277.18, 329.63, 440.00] },   // A minor - vi
                { time: 36, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 40, chords: [261.63, 329.63, 392.00, 523.25] },   // C major - I
                { time: 44, chords: [392.00, 493.88, 587.33, 783.99] },   // G major - V
                
                // Grand finale (48-60s) - Return home with suspension
                { time: 48, chords: [220.00, 277.18, 329.63, 440.00] },   // A minor - vi
                { time: 52, chords: [196.00, 246.94, 293.66, 392.00] },   // G major sus - V
                { time: 56, chords: [261.63, 329.63, 392.00, 523.25] }    // C major - I (final)
            ];
            
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;
                    
                    // Find current measure
                    let currentMeasure = measures[0];
                    for (let m = 0; m < measures.length; m++) {
                        if (t >= measures[m].time) {
                            currentMeasure = measures[m];
                        }
                    }
                    
                    const frequencies = currentMeasure.chords;
                    
                    // Rich organ voicing with multiple ranks (inspired by Bach's registrations)
                    for (let f = 0; f < frequencies.length; f++) {
                        const freq = frequencies[f];
                        
                        // Principal 8' (fundamental)
                        sample += Math.sin(2 * Math.PI * freq * t) * 0.20;
                        
                        // Octave 4' (first harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 2 * t) * 0.12;
                        
                        // Quint 2 2/3' (third harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 3 * t) * 0.08;
                        
                        // Super Octave 2' (fourth harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 4 * t) * 0.05;
                        
                        // Sub Bass 16' (pedal tone)
                        if (f === 0) { // Only on bass note
                            sample += Math.sin(2 * Math.PI * freq * 0.5 * t) * 0.15;
                        }
                        
                        // Tierce 1 3/5' (fifth harmonic - adds brilliance)
                        sample += Math.sin(2 * Math.PI * freq * 5 * t) * 0.03;
                    }
                    
                    // Baroque-style ornamentation (inspired by Bach's preludes)
                    const ornamentFreq = 4; // Slow trill/vibrato
                    const ornament = Math.sin(2 * Math.PI * ornamentFreq * t) * 0.004;
                    sample *= (1 + ornament);
                    
                    // Dynamic expression (crescendo and diminuendo like a real organist)
                    let expression = 1.0;
                    const measureProgress = (t % 4) / 4; // Position within measure
                    
                    // Slight swell at measure midpoint
                    expression = 0.85 + Math.sin(measureProgress * Math.PI) * 0.15;
                    
                    // Overall dynamics (forte -> piano -> forte)
                    let overallDynamics = 1.0;
                    if (t < 16) {
                        overallDynamics = 0.9; // Opening - moderately loud
                    } else if (t < 32) {
                        overallDynamics = 1.0; // Development - full
                    } else if (t < 48) {
                        overallDynamics = 0.85; // Middle - softer
                    } else {
                        overallDynamics = 1.0; // Finale - full again
                    }
                    
                    // Smooth transitions between chords (legato style)
                    let transitionEnvelope = 1.0;
                    const timeInMeasure = t % 4;
                    if (timeInMeasure < 0.1) {
                        transitionEnvelope = timeInMeasure / 0.1; // Quick attack
                    } else if (timeInMeasure > 3.8) {
                        transitionEnvelope = (4 - timeInMeasure) / 0.2; // Smooth release
                    }
                    
                    // Grand loop envelope
                    let loopEnvelope = 1.0;
                    const fadeTime = 2.0;
                    if (t < fadeTime) {
                        loopEnvelope = Math.pow(t / fadeTime, 0.5); // Smooth fade in
                    } else if (t > duration - fadeTime) {
                        loopEnvelope = Math.pow((duration - t) / fadeTime, 0.5); // Smooth fade out
                    }
                    
                    // Final mix with stereo width (slight delay for cathedral ambience)
                    const stereoDelay = (channel === 1) ? Math.sin(2 * Math.PI * 0.5 * t) * 0.02 : 0;
                    
                    data[i] = sample * expression * overallDynamics * transitionEnvelope * loopEnvelope * 0.28 * (1 + stereoDelay);
                }
            }
            
            return buffer;
        }
        
        function playBackgroundMusic() {
            if (backgroundMusic) return;
            
            const buffer = createChurchMusic();
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0.30; // 30% volume for background music
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start(0);
            
            backgroundMusic = source;
        }
        
        // Sword slash sound - DISABLED (silent)
        function playSwordSlashSound() {
            // Sound effect disabled per user request
            return;
        }
        
        // Divine special attack sound
        function playDivineSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.01, audioContext.currentTime); // 1% volume - very quiet
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        // Healing prayer sound
        function playHealSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C note
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E note
            oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G note
            
            gainNode.gain.setValueAtTime(0.01, audioContext.currentTime); // 1% volume - very quiet
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.5);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        // Hit impact sound
        function playHitSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.01, audioContext.currentTime); // 1% volume - very quiet
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Game State
        const gameState = {
            mode: null,
            health: 100,
            maxHealth: 100,
            special: 100,
            maxSpecial: 100,
            kills: 0,
            combo: 0,
            comboTimer: null,
            comboHits: 0,
            allies: [],
            enemies: [],
            leaders: [],
            isAttacking: false,
            gameStarted: false,
            prayTarget: null,
            leadersDefeated: 0,
            totalLeaders: 5,
            gameWon: false,
            currentChapter: 0,
            questActive: false,
            questComplete: false
        };

        const mobileControls = {
            joystick: { active: false, x: 0, y: 0 },
            moveVector: { x: 0, z: 0 }
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xA8D8A8); // Light green sky for grass field ambiance
        scene.fog = new THREE.Fog(0xB8E6B8, 60, 280); // Light green fog for grass fields

        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 18, 28);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xB8E6B8, 0.75); // Light green ambient
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xFFFAE6, 1.2); // Warm sunlight
        sunLight.position.set(70, 60, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xD4EED4, 0.5); // Green fill light
        fillLight.position.set(-50, 40, -40);
        scene.add(fillLight);

        const hemiLight = new THREE.HemisphereLight(0xA8D8A8, 0x4a7d35, 0.85); // Green sky, green ground
        scene.add(hemiLight);

        // Green Grassy Ground
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Brighter base green
            ctx.fillStyle = '#5a9d45';
            ctx.fillRect(0, 0, 512, 512);
            
            for (let i = 0; i < 12000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const greenShade = 90 + Math.random() * 60; // Brighter greens
                const grassType = Math.random();
                
                if (grassType < 0.7) {
                    // Vibrant light green
                    ctx.fillStyle = `rgba(${greenShade * 0.6}, ${greenShade * 1.1}, ${greenShade * 0.5}, ${0.5 + Math.random() * 0.3})`;
                } else {
                    // Rich medium green
                    ctx.fillStyle = `rgba(${greenShade * 0.4}, ${greenShade * 0.9}, ${greenShade * 0.4}, ${0.6 + Math.random() * 0.3})`;
                }
                
                const size = Math.random() * 3;
                ctx.fillRect(x, y, size, size);
            }
            
            // Fewer dirt patches for greener appearance
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brownShade = 80 + Math.random() * 40;
                ctx.fillStyle = `rgba(${brownShade}, ${brownShade * 0.7}, ${brownShade * 0.5}, 0.15)`;
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);
            return texture;
        }

        const groundGeometry = new THREE.PlaneGeometry(250, 250, 80, 80);
        const grassTexture = createGrassTexture();
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            map: grassTexture,
            color: 0x5a9d45, // Brighter, more vibrant green
            shininess: 3
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        
        const positions = ground.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const z = positions.getZ(i);
            let y = Math.sin(x * 0.015) * Math.cos(z * 0.015) * 3;
            y += Math.sin(x * 0.03) * Math.cos(z * 0.03) * 1.5;
            y += (Math.random() - 0.5) * 0.5;
            positions.setY(i, y);
        }
        positions.needsUpdate = true;
        ground.geometry.computeVertexNormals();
        scene.add(ground);

        // Grass tufts
        const grassTuftMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x3a6b2a,
            side: THREE.DoubleSide,
            flatShading: true
        });
        
        for (let i = 0; i < 200; i++) {
            const tuft = new THREE.Group();
            
            for (let j = 0; j < 10; j++) {
                const bladeGeometry = new THREE.ConeGeometry(0.04, 0.35 + Math.random() * 0.25, 3);
                const blade = new THREE.Mesh(bladeGeometry, grassTuftMaterial);
                blade.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.17,
                    (Math.random() - 0.5) * 0.4
                );
                blade.rotation.z = (Math.random() - 0.5) * 0.25;
                tuft.add(blade);
            }
            
            tuft.position.set(
                (Math.random() - 0.5) * 220,
                0,
                (Math.random() - 0.5) * 220
            );
            scene.add(tuft);
        }

        // Distant Castle
        const castle = new THREE.Group();
        const castleMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            flatShading: true
        });
        
        const keepGeometry = new THREE.BoxGeometry(18, 30, 18);
        const keep = new THREE.Mesh(keepGeometry, castleMaterial);
        keep.position.y = 15;
        keep.castShadow = true;
        castle.add(keep);
        
        for (let i = 0; i < 16; i++) {
            const merlonGeometry = new THREE.BoxGeometry(1.8, 2.5, 1.8);
            const merlon = new THREE.Mesh(merlonGeometry, castleMaterial);
            const angle = (i / 16) * Math.PI * 2;
            merlon.position.set(
                Math.cos(angle) * 9.5,
                31.5,
                Math.sin(angle) * 9.5
            );
            merlon.castShadow = true;
            castle.add(merlon);
        }
        
        const towerPositions = [[-12, 0, -12], [12, 0, -12], [-12, 0, 12], [12, 0, 12]];
        
        towerPositions.forEach(function(pos) {
            const towerGeometry = new THREE.CylinderGeometry(3.5, 4, 24, 16);
            const tower = new THREE.Mesh(towerGeometry, castleMaterial);
            tower.position.set(pos[0], 12, pos[2]);
            tower.castShadow = true;
            castle.add(tower);
            
            const roofGeometry = new THREE.ConeGeometry(4.8, 7, 16);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2a2a });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(pos[0], 27.5, pos[2]);
            roof.castShadow = true;
            castle.add(roof);
        });
        
        castle.position.set(-150, 0, -120);
        castle.scale.set(1.5, 1.5, 1.5);
        scene.add(castle);

        // Create Characters
        function createJoan() {
            const joan = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4169E1,
                shininess: 100,
                specular: 0x6495ED
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.5;
            torso.castShadow = true;
            joan.add(torso);
            
            const chestGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1.2, 16);
            const goldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 120,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, goldMaterial);
            chest.position.y = 2.9;
            chest.castShadow = true;
            joan.add(chest);
            
            const shoulderGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            leftShoulder.position.set(-0.95, 3.4, 0);
            leftShoulder.castShadow = true;
            joan.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            rightShoulder.position.set(0.95, 3.4, 0);
            rightShoulder.castShadow = true;
            joan.add(rightShoulder);
            
            const legGeometry = new THREE.CylinderGeometry(0.26, 0.3, 1.6, 12);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.32, 0.5, 0);
            leftLeg.castShadow = true;
            joan.add(leftLeg);
            joan.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.32, 0.5, 0);
            rightLeg.castShadow = true;
            joan.add(rightLeg);
            joan.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.22, 0.25, 1.9, 12);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.95, 2.5, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            joan.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.95, 2.5, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            joan.add(rightArm);
            joan.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.55, 20, 20);
            const skinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD1A3,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 4.1;
            head.castShadow = true;
            joan.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.6, 18, 14, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 4.3;
            hair.castShadow = true;
            joan.add(hair);
            
            const glowGeometry = new THREE.SphereGeometry(1.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2.5;
            joan.add(glow);
            joan.glow = glow;
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.8, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 150,
                specular: 0xFFFFFF
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.4;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.15);
            const guard = new THREE.Mesh(guardGeometry, goldMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(1, 2.5, 0);
            swordGroup.rotation.z = -0.3;
            joan.add(swordGroup);
            joan.sword = swordGroup;
            
            const capeGeometry = new THREE.BoxGeometry(1.5, 2.2, 0.1);
            const capeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C,
                shininess: 15,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 2.2, -0.5);
            cape.castShadow = true;
            joan.add(cape);
            joan.cape = cape;
            
            const glowLight = new THREE.PointLight(0xFFFFFF, 0.5, 10);
            glowLight.position.y = 4;
            joan.add(glowLight);
            joan.glowLight = glowLight;
            
            joan.position.set(0, 0, 0);
            joan.health = gameState.maxHealth;
            joan.isPlayer = true;
            joan.walkCycle = 0;
            joan.direction = 0;
            
            return joan;
        }

        function createAlexander() {
            const alex = createJoan();
            
            // Modify colors for Alexander
            alex.children.forEach(function(child) {
                if (child.material && child.material.color) {
                    if (child.material.color.getHex() === 0x4169E1) {
                        child.material.color.setHex(0x8B4513); // Bronze armor
                    }
                    if (child.material.color.getHex() === 0xDC143C) {
                        child.material.color.setHex(0x800020); // Burgundy cape
                    }
                }
            });
            
            return alex;
        }

        function createAlly() {
            const ally = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.58, 0.78, 1.9, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B8B8B,
                shininess: 95,
                specular: 0xCCCCCC
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.4;
            torso.castShadow = true;
            ally.add(torso);
            
            const chestGeometry = new THREE.CylinderGeometry(0.68, 0.78, 1.1, 16);
            const plateArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xA9A9A9,
                shininess: 110,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, plateArmorMaterial);
            chest.position.y = 2.7;
            chest.castShadow = true;
            ally.add(chest);
            
            const crossVGeometry = new THREE.BoxGeometry(0.08, 0.6, 0.12);
            const crossMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C
            });
            const crossV = new THREE.Mesh(crossVGeometry, crossMaterial);
            crossV.position.set(0, 2.7, 0.8);
            ally.add(crossV);
            
            const shoulderGeometry = new THREE.SphereGeometry(0.35, 14, 14);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            leftShoulder.position.set(-0.88, 3.25, 0);
            leftShoulder.castShadow = true;
            ally.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            rightShoulder.position.set(0.88, 3.25, 0);
            rightShoulder.castShadow = true;
            ally.add(rightShoulder);
            
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.28, 1.55, 14);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.31, 0.48, 0);
            leftLeg.castShadow = true;
            ally.add(leftLeg);
            ally.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.31, 0.48, 0);
            rightLeg.castShadow = true;
            ally.add(rightLeg);
            ally.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.21, 0.24, 1.75, 14);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.88, 2.4, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            ally.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.88, 2.4, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            ally.add(rightArm);
            ally.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.48, 16, 16);
            const skinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD1A3 });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.72;
            head.castShadow = true;
            ally.add(head);
            
            const helmetGeometry = new THREE.SphereGeometry(0.52, 16, 14, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const helmetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB0B0B0,
                shininess: 105
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 3.88;
            helmet.castShadow = true;
            ally.add(helmet);
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.11, 2.4, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xE8E8E8,
                shininess: 115
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.2;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            swordGroup.position.set(0.98, 2.4, 0);
            swordGroup.rotation.z = -0.3;
            ally.add(swordGroup);
            ally.sword = swordGroup;
            
            // Position will be set by calling function
            ally.targetEnemy = null;
            ally.attackCooldown = 0;
            ally.isAlly = true;
            ally.walkCycle = 0;
            ally.health = 80;
            
            return ally;
        }

        function positionAlliesInFormation(allies) {
            // Position 10 allies in formation around player
            const rows = 2;
            const soldiersPerRow = 5;
            const rowSpacing = 4;
            const colSpacing = 3.5;
            
            let allyIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < soldiersPerRow; col++) {
                    if (allyIndex < allies.length) {
                        const angle = (col / soldiersPerRow) * Math.PI * 2;
                        const distance = 8 + (row * rowSpacing);
                        
                        allies[allyIndex].position.set(
                            Math.cos(angle) * distance + (Math.random() - 0.5) * 2,
                            0,
                            Math.sin(angle) * distance + (Math.random() - 0.5) * 2
                        );
                        allyIndex++;
                    }
                }
            }
        }

        function createEnemy() {
            const enemy = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.55, 0.75, 1.8, 14);
            const darkArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a0000,
                shininess: 60
            });
            const torso = new THREE.Mesh(torsoGeometry, darkArmorMaterial);
            torso.position.y = 2.3;
            torso.castShadow = true;
            enemy.add(torso);
            
            const legGeometry = new THREE.CylinderGeometry(0.24, 0.27, 1.5, 12);
            const leftLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            leftLeg.position.set(-0.3, 0.45, 0);
            leftLeg.castShadow = true;
            enemy.add(leftLeg);
            enemy.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            rightLeg.position.set(0.3, 0.45, 0);
            rightLeg.castShadow = true;
            enemy.add(rightLeg);
            enemy.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.22, 1.7, 12);
            const leftArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            leftArm.position.set(-0.85, 2.3, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            enemy.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            rightArm.position.set(0.85, 2.3, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            enemy.add(rightArm);
            enemy.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.47, 16, 16);
            const darkSkinMaterial = new THREE.MeshPhongMaterial({ color: 0x505050 });
            const head = new THREE.Mesh(headGeometry, darkSkinMaterial);
            head.position.y = 3.65;
            head.castShadow = true;
            enemy.add(head);
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.5, 0.04);
            const darkBladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 90
            });
            const blade = new THREE.Mesh(bladeGeometry, darkBladeMaterial);
            blade.position.y = 1.25;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            swordGroup.position.set(0.95, 2.3, 0);
            swordGroup.rotation.z = -0.3;
            enemy.add(swordGroup);
            enemy.sword = swordGroup;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 20;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            enemy.health = 30;
            enemy.speed = 0.08 + Math.random() * 0.04;
            enemy.attackCooldown = 0;
            enemy.isEnemy = true;
            enemy.walkCycle = 0;
            
            return enemy;
        }

        function createEnemyLeader() {
            const leader = createEnemy();
            leader.scale.set(1.3, 1.3, 1.3);
            
            const crownGeometry = new THREE.CylinderGeometry(0.45, 0.38, 0.5, 12);
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                emissive: 0x332200
            });
            const crown = new THREE.Mesh(crownGeometry, crownMaterial);
            crown.position.y = 3.2;
            crown.castShadow = true;
            leader.add(crown);
            
            const auraGeometry = new THREE.RingGeometry(2, 3, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.1;
            leader.add(aura);
            leader.aura = aura;
            
            leader.health = 200;
            leader.maxHealth = 200;
            leader.isLeader = true;
            
            return leader;
        }

        let player;
        
        function selectMode(mode) {
            gameState.mode = mode;
            document.getElementById('modeSelection').classList.add('hidden');
            
            if (mode === 'story') {
                showCutscene(0);
            } else if (mode === 'alexander') {
                document.getElementById('characterName').textContent = '‚öîÔ∏è ALEXANDER THE GREAT ‚öîÔ∏è';
                player = createAlexander();
                scene.add(player);
                
                // Create 10 allied soldiers in formation
                for (let i = 0; i < 10; i++) {
                    const ally = createAlly();
                    gameState.allies.push(ally);
                    scene.add(ally);
                }
                positionAlliesInFormation(gameState.allies);
                
                gameState.totalLeaders = 8;
                document.getElementById('totalLeaders').textContent = '8';
                showAlexanderIntro();
            } else {
                // Arcade mode
                player = createJoan();
                scene.add(player);
                
                // Create 10 allied soldiers in formation
                for (let i = 0; i < 10; i++) {
                    const ally = createAlly();
                    gameState.allies.push(ally);
                    scene.add(ally);
                }
                positionAlliesInFormation(gameState.allies);
                
                // Start background music
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                playBackgroundMusic();
                
                gameState.gameStarted = true;
                animate();
            }
        }

        function showAlexanderIntro() {
            document.getElementById('cutsceneTitle').textContent = alexanderStory.title;
            document.getElementById('cutsceneText').textContent = alexanderStory.text;
            document.getElementById('cutsceneScreen').classList.remove('hidden');
        }

        function showCutscene(chapterIndex) {
            const chapter = storyChapters[chapterIndex];
            document.getElementById('cutsceneTitle').textContent = chapter.title;
            document.getElementById('cutsceneText').textContent = chapter.text;
            document.getElementById('cutsceneScreen').classList.remove('hidden');
        }

        function endCutscene() {
            document.getElementById('cutsceneScreen').classList.add('hidden');
            
            // Start background music
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
            
            if (gameState.mode === 'story') {
                showDialogue(gameState.currentChapter);
            } else if (gameState.mode === 'alexander') {
                gameState.gameStarted = true;
                gameState.questActive = true;
                document.getElementById('questLog').classList.remove('hidden');
                document.getElementById('questObjective').textContent = alexanderStory.quest;
                animate();
            }
        }

        function showDialogue(chapterIndex) {
            const chapter = storyChapters[chapterIndex];
            const dialogue = chapter.dialogue;
            
            document.getElementById('speakerName').textContent = dialogue.speaker;
            document.getElementById('dialogueText').textContent = dialogue.text;
            
            const optionsDiv = document.getElementById('dialogueOptions');
            optionsDiv.innerHTML = '';
            
            dialogue.options.forEach(function(option) {
                const button = document.createElement('div');
                button.className = 'dialogue-option';
                button.textContent = option.text;
                button.onclick = function() {
                    if (option.response === 'quest') {
                        startQuest(chapterIndex);
                    }
                };
                optionsDiv.appendChild(button);
            });
            
            document.getElementById('dialogueScreen').classList.remove('hidden');
        }

        function startQuest(chapterIndex) {
            document.getElementById('dialogueScreen').classList.add('hidden');
            
            const chapter = storyChapters[chapterIndex];
            
            if (!player) {
                player = createJoan();
                scene.add(player);
                
                // Create 10 allied soldiers in formation
                for (let i = 0; i < 10; i++) {
                    const ally = createAlly();
                    gameState.allies.push(ally);
                    scene.add(ally);
                }
                positionAlliesInFormation(gameState.allies);
            }
            
            gameState.questActive = true;
            gameState.questComplete = false;
            gameState.kills = 0;
            gameState.leadersDefeated = 0;
            
            if (chapter.objective.type === 'leaders') {
                gameState.totalLeaders = chapter.objective.count;
                document.getElementById('totalLeaders').textContent = chapter.objective.count;
            }
            
            document.getElementById('questLog').classList.remove('hidden');
            document.getElementById('questObjective').textContent = chapter.quest;
            
            // Start background music
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
            
            gameState.gameStarted = true;
            animate();
        }

        function checkQuestComplete() {
            if (!gameState.questActive || gameState.questComplete) return;
            
            const chapter = storyChapters[gameState.currentChapter];
            let complete = false;
            
            if (gameState.mode === 'alexander') {
                if (gameState.kills >= 50 && gameState.leadersDefeated >= 8) {
                    complete = true;
                }
            } else if (chapter.objective.type === 'kills') {
                if (gameState.kills >= chapter.objective.count) {
                    complete = true;
                }
            } else if (chapter.objective.type === 'leaders') {
                if (gameState.leadersDefeated >= chapter.objective.count) {
                    complete = true;
                }
            }
            
            if (complete) {
                gameState.questComplete = true;
                gameState.questActive = false;
                
                if (gameState.mode === 'alexander' || chapter.nextChapter === -1) {
                    showVictory();
                } else {
                    gameState.currentChapter = chapter.nextChapter;
                    setTimeout(function() {
                        showCutscene(gameState.currentChapter);
                    }, 1000);
                }
            }
        }

        function showVictory() {
            document.getElementById('victoryMessage').textContent = 
                gameState.mode === 'alexander' ? 
                'You have conquered the Persian Empire! History remembers Alexander the Great!' :
                'France is saved! Joan of Arc has fulfilled her divine mission!';
            document.getElementById('victoryScreen').classList.remove('hidden');
        }

        // Joystick Controls
        const joystickBase = document.getElementById('joystickBase');
        const joystickStick = document.getElementById('joystickStick');
        
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        
        joystickBase.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            joystickActive = true;
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
        }, { passive: false });
        
        joystickBase.addEventListener('touchmove', function(e) {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - joystickStartX;
            const deltaY = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 38;
            const clampedDistance = Math.min(distance, maxDistance);
            
            const angle = Math.atan2(deltaY, deltaX);
            const clampedX = Math.cos(angle) * clampedDistance;
            const clampedY = Math.sin(angle) * clampedDistance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;
            
            mobileControls.moveVector.x = clampedX / maxDistance;
            mobileControls.moveVector.z = clampedY / maxDistance;
        }, { passive: false });
        
        joystickBase.addEventListener('touchend', function(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            mobileControls.moveVector.x = 0;
            mobileControls.moveVector.z = 0;
        }, { passive: false });

        document.getElementById('attackButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (!gameState.isAttacking && gameState.gameStarted) {
                playerAttack();
            }
        }, { passive: false });
        
        document.getElementById('specialButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.special >= 50 && gameState.gameStarted) {
                specialAttack();
            }
        }, { passive: false });
        
        document.getElementById('prayButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.gameStarted) {
                prayForLeader();
            }
        }, { passive: false });
        
        function prayForLeader() {
            // Heal player by 15 HP
            gameState.health = Math.min(gameState.maxHealth, gameState.health + 15);
            updateUI();
            
            // Play healing sound
            playHealSound();
            
            // Create healing effect
            createHealingEffect(player.position);
            
            // Flash effect
            const flashDiv = document.createElement('div');
            flashDiv.style.position = 'fixed';
            flashDiv.style.top = '0';
            flashDiv.style.left = '0';
            flashDiv.style.width = '100%';
            flashDiv.style.height = '100%';
            flashDiv.style.background = 'rgba(255, 215, 0, 0.3)';
            flashDiv.style.pointerEvents = 'none';
            flashDiv.style.zIndex = '50';
            document.body.appendChild(flashDiv);
            
            setTimeout(function() {
                document.body.removeChild(flashDiv);
            }, 500);
            
            // Find and mark nearest leader (if any)
            if (gameState.leaders.length > 0) {
                let nearestLeader = null;
                let nearestDistance = Infinity;
                
                gameState.leaders.forEach(function(leader) {
                    const distance = player.position.distanceTo(leader.position);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestLeader = leader;
                    }
                });
                
                gameState.prayTarget = nearestLeader;
            }
        }

        function playerAttack() {
            gameState.isAttacking = true;
            
            // Play sword slash sound
            playSwordSlashSound();
            
            const sword = player.sword;
            const originalRotation = sword.rotation.z;
            
            let swingProgress = 0;
            function animateSwing() {
                swingProgress += 0.15;
                if (swingProgress < 1) {
                    sword.rotation.z = originalRotation - Math.sin(swingProgress * Math.PI) * Math.PI / 2;
                    requestAnimationFrame(animateSwing);
                } else {
                    sword.rotation.z = originalRotation;
                    gameState.isAttacking = false;
                }
            }
            animateSwing();
            
            let hitSomething = false;
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 5) {
                    const damage = enemy.isLeader ? 15 : 25;
                    enemy.health -= damage;
                    hitSomething = true;
                    
                    // Play hit sound
                    playHitSound();
                    
                    // Create slash effect
                    createSlashEffect(enemy.position, new THREE.Vector3());
                    
                    // Knockback
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(3.5));
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
            
            if (hitSomething) {
                updateCombo();
            }
        }

        function specialAttack() {
            gameState.special -= 50;
            updateUI();
            
            // Play divine sound
            playDivineSound();
            
            // Create divine explosion effect at player position
            createDivineExplosion(player.position);
            
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 15) {
                    enemy.health -= 50;
                    
                    // Knockback enemies away from player
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(6));
                    
                    // Create impact effect on each enemy
                    createSlashEffect(enemy.position, direction);
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
        }

        function killEnemy(enemy) {
            scene.remove(enemy);
            gameState.enemies = gameState.enemies.filter(function(e) { return e !== enemy; });
            
            if (enemy.isLeader) {
                gameState.leaders = gameState.leaders.filter(function(l) { return l !== enemy; });
                gameState.leadersDefeated++;
            }
            
            gameState.kills++;
            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 10);
            updateUI();
            checkQuestComplete();
        }

        function updateCombo() {
            gameState.combo++;
            gameState.comboHits++;
            
            if (gameState.comboTimer) {
                clearTimeout(gameState.comboTimer);
            }
            
            const comboElement = document.getElementById('comboCounter');
            comboElement.textContent = gameState.combo + ' HIT COMBO!';
            comboElement.classList.add('show');
            
            gameState.comboTimer = setTimeout(function() {
                gameState.combo = 0;
                comboElement.classList.remove('show');
            }, 2000);
        }

        function updateUI() {
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('specialBar').style.width = (gameState.special / gameState.maxSpecial * 100) + '%';
            document.getElementById('killCount').textContent = gameState.kills;
            document.getElementById('leaderCount').textContent = gameState.leadersDefeated;
            document.getElementById('comboHits').textContent = gameState.comboHits;
        }

        // Visual Effects
        function createSlashEffect(position, direction) {
            const particles = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                
                const angle = (i / 8) * Math.PI * 2;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * 0.5;
                particle.position.z += Math.sin(angle) * 0.5;
                particle.position.y += 2;
                
                particle.velocity = {
                    x: Math.cos(angle) * 0.2,
                    y: 0.1,
                    z: Math.sin(angle) * 0.2
                };
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            let life = 0;
            const animateParticles = function() {
                life++;
                if (life > 15) {
                    scene.remove(particles);
                    return;
                }
                
                particles.children.forEach(function(particle) {
                    particle.position.x += particle.velocity.x;
                    particle.position.y += particle.velocity.y;
                    particle.position.z += particle.velocity.z;
                    particle.velocity.y -= 0.02;
                    particle.material.opacity -= 0.05;
                });
                
                requestAnimationFrame(animateParticles);
            };
            animateParticles();
        }
        
        function createDivineExplosion(position) {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8
            });
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(position);
            explosion.position.y = 2;
            scene.add(explosion);
            
            let scale = 1;
            const animateExplosion = function() {
                scale += 0.8;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.08;
                
                if (explosion.material.opacity <= 0) {
                    scene.remove(explosion);
                } else {
                    requestAnimationFrame(animateExplosion);
                }
            };
            animateExplosion();
        }
        
        function createHealingEffect(position) {
            const particles = new THREE.Group();
            
            for (let i = 0; i < 12; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geometry, material);
                
                const angle = (i / 12) * Math.PI * 2;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * 1.5;
                particle.position.z += Math.sin(angle) * 1.5;
                particle.position.y += 0.5;
                
                particle.targetY = position.y + 3;
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            let life = 0;
            const animateHealing = function() {
                life++;
                if (life > 30) {
                    scene.remove(particles);
                    return;
                }
                
                particles.children.forEach(function(particle) {
                    particle.position.y += 0.1;
                    particle.material.opacity -= 0.03;
                });
                
                requestAnimationFrame(animateHealing);
            };
            animateHealing();
        }

        function checkCollision(character, newX, newZ) {
            const collisionRadius = 2.5; // Minimum distance between characters
            const testPosition = new THREE.Vector3(newX, character.position.y, newZ);
            
            // Check collision with player
            if (character !== player) {
                const distToPlayer = testPosition.distanceTo(player.position);
                if (distToPlayer < collisionRadius) {
                    return true;
                }
            }
            
            // Check collision with allies
            for (let i = 0; i < gameState.allies.length; i++) {
                const ally = gameState.allies[i];
                if (character !== ally) {
                    const distToAlly = testPosition.distanceTo(ally.position);
                    if (distToAlly < collisionRadius) {
                        return true;
                    }
                }
            }
            
            // Check collision with enemies
            for (let i = 0; i < gameState.enemies.length; i++) {
                const enemy = gameState.enemies[i];
                if (character !== enemy) {
                    const distToEnemy = testPosition.distanceTo(enemy.position);
                    if (distToEnemy < collisionRadius) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function applyCollisionAvoidance(character, direction, speed) {
            const newX = character.position.x + direction.x * speed;
            const newZ = character.position.z + direction.z * speed;
            
            // Check if new position would collide
            if (!checkCollision(character, newX, newZ)) {
                // No collision, move normally
                character.position.x = newX;
                character.position.z = newZ;
                return true;
            } else {
                // Try moving just in X direction
                if (!checkCollision(character, newX, character.position.z)) {
                    character.position.x = newX;
                    return true;
                }
                
                // Try moving just in Z direction
                if (!checkCollision(character, character.position.x, newZ)) {
                    character.position.z = newZ;
                    return true;
                }
                
                // Can't move, blocked
                return false;
            }
        }

        function updateEnemy(enemy) {
            const playerDistance = enemy.position.distanceTo(player.position);
            
            if (playerDistance > 3) {
                const direction = new THREE.Vector3()
                    .subVectors(player.position, enemy.position)
                    .normalize();
                
                // Apply collision-aware movement
                const moved = applyCollisionAvoidance(enemy, direction, enemy.speed);
                
                if (moved) {
                    enemy.lookAt(player.position);
                    
                    enemy.walkCycle += 0.14;
                    const legSwing = Math.sin(enemy.walkCycle) * 0.5;
                    enemy.leftLeg.rotation.x = legSwing;
                    enemy.rightLeg.rotation.x = -legSwing;
                }
            } else {
                enemy.lookAt(player.position);
                
                if (enemy.attackCooldown <= 0) {
                    enemy.attackCooldown = 90;
                    gameState.health -= 5;
                    updateUI();
                    
                    if (gameState.health <= 0) {
                        alert('Defeated! You killed ' + gameState.kills + ' enemies.');
                        location.reload();
                    }
                }
            }
            
            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
            }
        }

        function updateAlly(ally) {
            if (!ally.targetEnemy || ally.targetEnemy.health <= 0) {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                gameState.enemies.forEach(function(enemy) {
                    const distance = ally.position.distanceTo(enemy.position);
                    if (distance < nearestDistance && distance < 35) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                ally.targetEnemy = nearestEnemy;
            }
            
            if (ally.targetEnemy) {
                const direction = new THREE.Vector3()
                    .subVectors(ally.targetEnemy.position, ally.position);
                const distance = direction.length();
                
                if (distance > 3.5) {
                    direction.normalize();
                    
                    // Apply collision-aware movement
                    const moved = applyCollisionAvoidance(ally, direction, 0.11);
                    
                    if (moved) {
                        ally.lookAt(ally.targetEnemy.position);
                        
                        ally.walkCycle += 0.16;
                        const legSwing = Math.sin(ally.walkCycle) * 0.52;
                        ally.leftLeg.rotation.x = legSwing;
                        ally.rightLeg.rotation.x = -legSwing;
                        ally.rightArm.rotation.x = Math.sin(ally.walkCycle) * 0.33;
                    }
                } else {
                    ally.lookAt(ally.targetEnemy.position);
                    
                    if (ally.attackCooldown <= 0) {
                        ally.attackCooldown = 65;
                        ally.targetEnemy.health -= 18;
                        
                        if (ally.sword) {
                            ally.sword.rotation.z = -Math.PI / 3;
                            setTimeout(function() {
                                if (ally.sword) ally.sword.rotation.z = -0.3;
                            }, 220);
                        }
                        
                        if (ally.targetEnemy.health <= 0) {
                            killEnemy(ally.targetEnemy);
                            ally.targetEnemy = null;
                        }
                    }
                }
            }
            
            if (ally.attackCooldown > 0) {
                ally.attackCooldown--;
            }
        }

        function spawnEnemies() {
            if (gameState.enemies.length < 20) {
                const enemy = createEnemy();
                gameState.enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function spawnLeader() {
            const maxLeaders = gameState.mode === 'alexander' ? 2 : 2;
            if (gameState.leaders.length < maxLeaders && gameState.leadersDefeated < gameState.totalLeaders) {
                const leader = createEnemyLeader();
                gameState.leaders.push(leader);
                gameState.enemies.push(leader);
                scene.add(leader);
            }
        }

        let lastTime = Date.now();
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let spawnTimer = 0;
        let leaderSpawnTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameState.gameStarted || !player) {
                renderer.render(scene, camera);
                return;
            }
            
            const currentTime = Date.now();
            lastTime = currentTime;

            frameCount++;
            if (currentTime - lastFPSUpdate >= 1000) {
                document.getElementById('fpsValue').textContent = frameCount;
                frameCount = 0;
                lastFPSUpdate = currentTime;
            }

            const moveSpeed = 0.22;
            let isMoving = false;
            
            if (joystickActive) {
                const joyX = mobileControls.moveVector.x;
                const joyZ = mobileControls.moveVector.z;
                
                if (Math.abs(joyX) > 0.1 || Math.abs(joyZ) > 0.1) {
                    isMoving = true;
                    
                    const angle = Math.atan2(joyX, joyZ);
                    let direction = Math.round(angle / (Math.PI / 4));
                    if (direction < 0) direction += 8;
                    if (direction >= 8) direction = 0;
                    
                    const magnitude = Math.min(Math.sqrt(joyX * joyX + joyZ * joyZ), 1);
                    
                    // Calculate movement direction
                    const moveDir = {
                        x: Math.sin(angle) * magnitude,
                        z: Math.cos(angle) * magnitude
                    };
                    
                    // Apply collision-aware movement
                    const moved = applyCollisionAvoidance(player, moveDir, moveSpeed);
                    
                    if (moved) {
                        player.rotation.y = angle;
                        player.direction = direction;
                    } else {
                        // If blocked, stop walking animation
                        isMoving = false;
                    }
                }
            }

            if (isMoving) {
                player.walkCycle += 0.18;
                
                const legSwing = Math.sin(player.walkCycle) * 0.6;
                player.leftLeg.rotation.x = legSwing;
                player.rightLeg.rotation.x = -legSwing;
                player.rightArm.rotation.x = Math.sin(player.walkCycle) * 0.4;
                
                const bodyBob = Math.abs(Math.sin(player.walkCycle)) * 0.15;
                player.position.y = bodyBob;
                
                player.cape.rotation.x = Math.sin(player.walkCycle * 0.5) * 0.12;
            } else {
                player.leftLeg.rotation.x *= 0.9;
                player.rightLeg.rotation.x *= 0.9;
                player.rightArm.rotation.x *= 0.9;
                player.position.y *= 0.9;
                player.cape.rotation.x *= 0.9;
                
                const breathe = Math.sin(currentTime * 0.001) * 0.02;
                player.position.y = breathe;
            }

            player.position.x = Math.max(-110, Math.min(110, player.position.x));
            player.position.z = Math.max(-110, Math.min(110, player.position.z));

            if (player.glow && player.glowLight) {
                player.glow.material.opacity = 0.12 + Math.sin(currentTime * 0.002) * 0.08;
                player.glowLight.intensity = 0.6 + Math.sin(currentTime * 0.003) * 0.4;
            }

            gameState.enemies.forEach(updateEnemy);
            gameState.allies.forEach(updateAlly);

            spawnTimer++;
            if (spawnTimer > 120) {
                spawnTimer = 0;
                spawnEnemies();
            }
            
            // Spawn leaders every 30 seconds (1800 frames at 60fps)
            leaderSpawnTimer++;
            if (leaderSpawnTimer > 1800) {
                leaderSpawnTimer = 0;
                spawnLeader();
            }

            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 28;
            camera.lookAt(player.position);

            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 0.05);
            if (Math.random() < 0.01) {
                updateUI();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        renderer.render(scene, camera);
    </script>
</body>
</html>
