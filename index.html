<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Joan of Arc: Divine Warriors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Cinzel:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'Lora', serif;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(184, 134, 11, 0.95));
            padding: 3px 5px;
            border: 1px solid #FFD700;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            color: #FFD700;
            text-shadow: 1px 1px 2px #000;
            font-size: 8px;
            transform: scale(0.375);
            transform-origin: top left;
        }
        
        #hud h2 {
            font-family: 'Cinzel', serif;
            font-size: 22px;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .stat {
            margin: 6px 0;
            font-size: 13px;
        }
        
        .bar-container {
            width: 160px;
            height: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            margin-top: 4px;
            position: relative;
            overflow: hidden;
            border-radius: 3px;
        }
        
        .bar {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #healthBar {
            background: linear-gradient(90deg, #8B0000, #DC143C);
            box-shadow: 0 0 10px #DC143C;
        }
        
        #specialBar {
            background: linear-gradient(90deg, #0000CD, #4169E1);
            box-shadow: 0 0 10px #4169E1;
        }
        
        .mobile-control {
            position: absolute;
            pointer-events: all;
            touch-action: none;
        }
        
        #joystickContainer {
            bottom: 25px;
            left: 25px;
            width: 140px;
            height: 140px;
        }
        
        #joystickBase {
            width: 140px;
            height: 140px;
            background: radial-gradient(circle, rgba(50, 50, 50, 0.85), rgba(20, 20, 20, 0.95));
            border: 4px solid rgba(255, 215, 0, 0.7);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.9);
        }
        
        #joystickStick {
            width: 65px;
            height: 65px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            border: 3px solid #FFD700;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
            transition: all 0.08s ease;
        }
        
        #attackButtons {
            bottom: 25px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        
        .attack-button {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            border: 4px solid #FFD700;
            font-family: 'Lora', serif;
            font-size: 13px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.1s;
            touch-action: none;
        }
        
        #attackButton {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.95), rgba(139, 0, 0, 0.95));
        }
        
        #specialButton {
            background: radial-gradient(circle, rgba(65, 105, 225, 0.95), rgba(0, 0, 139, 0.95));
        }
        
        #prayButton {
            background: radial-gradient(circle, rgba(255, 215, 0, 0.95), rgba(184, 134, 11, 0.95));
            width: 65px;
            height: 65px;
            font-size: 11px;
        }
        
        .attack-button:active {
            transform: scale(0.92);
        }
        
        #comboCounter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 56px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            opacity: 0;
            transition: opacity 0.3s;
            font-family: 'Cinzel', serif;
            pointer-events: none;
        }
        
        #comboCounter.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        #modeSelection, #startScreen, #cutsceneScreen, #dialogueScreen, #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000, #1a0000, #000000);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: all;
        }
        
        #modeSelection h1 {
            font-family: 'Cinzel', serif;
            font-size: 52px;
            color: #FFD700;
            text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000;
            margin-bottom: 50px;
            animation: glow 2s ease-in-out infinite;
        }
        
        .mode-button {
            font-family: 'Lora', serif;
            font-size: 24px;
            padding: 18px 50px;
            margin: 15px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 12px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 35px rgba(255, 215, 0, 0.6);
            transition: all 0.3s;
        }
        
        .mode-button:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #DC143C, #8B0000);
        }
        
        .mode-button:active {
            transform: scale(0.98);
        }
        
        #cutsceneScreen {
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            overflow-y: auto;
        }
        
        #cutsceneContent {
            max-width: 900px;
            padding: 40px;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #cutsceneTitle {
            font-family: 'Cinzel', serif;
            font-size: 42px;
            color: #FFD700;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 #8B0000;
            -webkit-user-select: text;
            user-select: text;
        }
        
        #cutsceneText {
            font-family: 'Lora', serif;
            font-size: 18px;
            color: #E8E8E8;
            line-height: 1.9;
            margin-bottom: 40px;
            text-shadow: 1px 1px 2px #000;
            white-space: pre-wrap;
            text-align: left;
            max-height: 60vh;
            overflow-y: auto;
            padding: 20px;
            -webkit-user-select: text;
            user-select: text;
        }
        
        #continueButton {
            font-family: 'Lora', serif;
            font-size: 22px;
            padding: 15px 45px;
            background: linear-gradient(135deg, #8B0000, #DC143C);
            color: #FFD700;
            border: 4px solid #FFD700;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 2px 2px 4px #000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        
        #dialogueScreen {
            background: linear-gradient(135deg, #2a2a3e, #1a1a2e);
        }
        
        #dialogueBox {
            max-width: 800px;
            padding: 35px;
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #FFD700;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.7);
        }
        
        #speakerName {
            font-family: 'Cinzel', serif;
            font-size: 32px;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #8B0000;
        }
        
        #dialogueText {
            font-size: 19px;
            color: #E8E8E8;
            line-height: 1.7;
            margin-bottom: 30px;
            text-shadow: 1px 1px 2px #000;
        }
        
        .dialogue-option {
            font-family: 'Lora', serif;
            font-size: 17px;
            padding: 12px 30px;
            margin: 10px;
            background: linear-gradient(135deg, #4a4a5e, #2a2a3e);
            color: #FFD700;
            border: 3px solid #FFD700;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 1px 1px 3px #000;
            transition: all 0.2s;
        }
        
        .dialogue-option:hover {
            background: linear-gradient(135deg, #8B0000, #DC143C);
            transform: translateX(10px);
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 25px #FFD700; }
            50% { text-shadow: 4px 4px 0 #8B0000, -2px -2px 0 #000, 0 0 45px #FFD700; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #fpsCounter {
            position: absolute;
            top: 12px;
            right: 12px;
            color: #FFD700;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            border: 2px solid #FFD700;
            font-weight: bold;
        }
        
        #questLog {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border: 3px solid #FFD700;
            border-radius: 8px;
            max-width: 320px;
            color: #FFD700;
            text-shadow: 1px 1px 2px #000;
            transform: scale(0.375);
            transform-origin: top left;
        }
        
        #questLog h3 {
            font-family: 'Cinzel', serif;
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #questObjective {
            font-size: 14px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="modeSelection">
        <h1>JOAN OF ARC</h1>
        <h3 style="color: #FFD700; font-size: 28px; margin-bottom: 35px;">‚öîÔ∏è Divine Warriors ‚öîÔ∏è</h3>
        <button class="mode-button" onclick="selectMode('story')">STORY MODE</button>
        <button class="mode-button" onclick="selectMode('alexander')">ALEXANDER THE GREAT STORY</button>
        <button class="mode-button" onclick="selectMode('gun')">GUN MODE</button>
    </div>
    
    <div id="cutsceneScreen" class="hidden">
        <div id="cutsceneContent">
            <h2 id="cutsceneTitle"></h2>
            <p id="cutsceneText"></p>
            <button id="continueButton" onclick="endCutscene()">CONTINUE</button>
        </div>
    </div>
    
    <div id="dialogueScreen" class="hidden">
        <div id="dialogueBox">
            <h2 id="speakerName"></h2>
            <p id="dialogueText"></p>
            <div id="dialogueOptions"></div>
        </div>
    </div>
    
    <div id="victoryScreen" class="hidden">
        <div style="text-align: center;">
            <h1 style="font-family: 'Cinzel', serif; font-size: 48px; color: #FFD700; text-shadow: 4px 4px 0 #8B0000; margin-bottom: 30px;">
                VICTORY!
            </h1>
            <p id="victoryMessage" style="font-size: 24px; color: #E8E8E8; margin-bottom: 30px;"></p>
            <button class="mode-button" onclick="location.reload()">RETURN TO MENU</button>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <h2 id="characterName">‚öúÔ∏è JOAN OF ARC ‚öúÔ∏è</h2>
            <div class="stat">
                Health
                <div class="bar-container">
                    <div id="healthBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">
                Divine Power
                <div class="bar-container">
                    <div id="specialBar" class="bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">Kills: <span id="killCount">0</span></div>
            <div class="stat">Leaders: <span id="leaderCount">0</span>/<span id="totalLeaders">5</span></div>
            <div class="stat">Combo: <span id="comboHits">0</span></div>
        </div>
        
        <div id="questLog" class="hidden">
            <h3>üìú Quest</h3>
            <p id="questObjective"></p>
        </div>
        
        <div id="fpsCounter">FPS: <span id="fpsValue">0</span></div>
        
        <div id="comboCounter">0 HIT COMBO!</div>
        
        <div id="joystickContainer" class="mobile-control">
            <div id="joystickBase">
                <div id="joystickStick"></div>
            </div>
        </div>
        
        <div id="attackButtons" class="mobile-control">
            <div id="attackButton" class="attack-button">ATTACK</div>
            <div id="specialButton" class="attack-button">SPECIAL</div>
            <div id="prayButton" class="attack-button">PRAY</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Story Data - Joan of Arc Biographical Story Mode
        const storyChapters = [
            {
                title: "Chapter 1: Childhood in Domr√©my - 1412-1424",
                text: "Born in the village of Domr√©my to Jacques d'Arc and Isabelle Rom√©e, young Jeanne grows up during the Hundred Years' War. She tends sheep, learns to sew, and attends church regularly. At age 12, she begins hearing divine voices.",
                location: "Domr√©my, France",
                gameplay: "church",
                dialogue: {
                    speaker: "Isabelle Rom√©e (Mother)",
                    text: "Jeanne, you spend so much time in prayer at the church. What troubles your heart, my daughter?",
                    options: [
                        { text: "I hear voices, Mother. They speak of France's suffering.", response: "quest" },
                        { text: "I must pray for our kingdom. God has a purpose for me.", response: "quest" }
                    ]
                },
                quest: "Visit the church and pray 5 times for France's salvation",
                objective: { type: "prayers", count: 5 },
                historicalQuote: "I learned my Pater Noster, Ave Maria, and Credo from my mother. I was taught my faith by her and not by any other. I went to confession once a year to my own cur√©, and when he was prevented, I went to another priest with his permission. I have sometimes confessed twice or three times to mendicant friars, at Neufch√¢teau. I received the Sacrament of the Eucharist at Easter time... I sewed and spun, and when I watched the flocks, I sang the birds away. ‚Äî Joan's own testimony, Trial of Condemnation, February 21-22, 1431",
                scholarlyQuote: "Joan was born in 1412 in Domr√©my, a village on the borders of Lorraine and Champagne. Her parents, Jacques d'Arc and Isabelle Rom√©e, were prosperous peasants who owned approximately 50 acres of land and a stone house. Joan's childhood was marked by profound piety that distinguished her from other children. Neighbors testified that she attended Mass daily, went to confession frequently, and wept when church bells rang. She was described as exceptionally devout even in an intensely religious age. The parish priest, Guillaume Fronte, stated she was 'a good Christian, such as you would wish your daughter to be.' Her religious fervor was not seen as unusual until she began speaking of voices and a divine mission. ‚Äî R√©gine Pernoud and Marie-V√©ronique Clin, 'Joan of Arc: Her Story', St. Martin's Griffin, 1999",
                nextChapter: 1
            },
            {
                title: "Chapter 2: The Voices - 1424-1428",
                text: "At age 13, Joan experiences her first vision in her father's garden. Saint Michael, Saint Catherine, and Saint Margaret appear to her, commanding her to save France and crown the Dauphin at Reims. For four years, she keeps this divine mission secret.",
                location: "Domr√©my Garden",
                gameplay: "church",
                dialogue: {
                    speaker: "Saint Michael (Vision)",
                    text: "Daughter of God, you must go to France and raise the siege of Orl√©ans. You will lead the Dauphin to Reims for his coronation.",
                    options: [
                        { text: "But I am only a poor girl who knows nothing of war!", response: "quest" },
                        { text: "If this is God's will, I will obey.", response: "quest" }
                    ]
                },
                quest: "Pray at the church altar to receive divine guidance - Complete 3 prayers",
                objective: { type: "prayers", count: 3 },
                historicalQuote: "I was in my thirteenth year when I heard a voice from God to help me govern my conduct. And the first time I was very fearful. And came this voice, about the hour of noon, in the summer time, in my father's garden... I heard the voice on the right-hand side... and rarely do I hear it without a brightness. This brightness comes from the same side as the voice is heard. ‚Äî Joan's testimony at her trial, February 22, 1431",
                scholarlyQuote: "The voices first came to Joan when she was approximately thirteen years old. According to her trial testimony, she initially heard them in her father's garden during summer, accompanied by a great light. She identified the voices as belonging to St. Michael the Archangel, St. Catherine of Alexandria, and St. Margaret of Antioch. These saints commanded her to drive out the English and lead the Dauphin to his coronation at Reims. ‚Äî Marina Warner, 'Joan of Arc: The Image of Female Heroism', Oxford University Press, 1981",
                nextChapter: 2
            },
            {
                title: "Chapter 3: The Journey Begins - 1428",
                text: "At 16, Joan can no longer ignore her voices. She travels to Vaucouleurs to convince Captain Robert de Baudricourt to grant her an armed escort to the Dauphin. Initially dismissed, she persists and eventually convinces him of her divine mission.",
                location: "Vaucouleurs",
                dialogue: {
                    speaker: "Robert de Baudricourt",
                    text: "You return again, girl? Do you still claim God sends you to save France? This is madness! I should send you back to your father with a good beating!",
                    options: [
                        { text: "Before mid-Lent, I must be with the King. No one else can save France.", response: "quest" },
                        { text: "I tell you in God's name: the Dauphin will make me his commander!", response: "quest" }
                    ]
                },
                quest: "Prove your faith - Defeat 15 bandits threatening the town",
                objective: { type: "kills", count: 15 },
                historicalQuote: "I went to Robert de Baudricourt in the town of Vaucouleurs, and I told him that I must go to France... He refused me twice. The third time he received me and gave me men. The voice had told me that so it would be. ‚Äî Joan's testimony, Trial of Condemnation, 1431",
                scholarlyQuote: "Joan made her first attempt to see Robert de Baudricourt in May 1428. She was initially rebuffed with mockery and told to return to her father. Undeterred, she remained in Vaucouleurs and tried again in January 1429. This time, her persistence, combined with her accurate prediction of a French military defeat near Orl√©ans, convinced Baudricourt to grant her request. He provided her with a small armed escort, a horse, and male clothing for the dangerous journey. ‚Äî R√©gine Pernoud, 'Joan of Arc: By Herself and Her Witnesses', Scarborough House, 1994",
                nextChapter: 3
            },
            {
                title: "Chapter 4: Journey to Chinon - 1429",
                text: "Joan travels 11 days and 300 miles through enemy territory to reach the Dauphin. Dressed in male clothing for protection, she rides day and night, passing through English-held lands. Her small escort includes Jean de Metz and Bertrand de Poulengy.",
                location: "Road to Chinon",
                dialogue: {
                    speaker: "Jean de Metz",
                    text: "We must pass through Burgundian territory by nightfall. The English patrol these roads. Are you certain we should continue, Joan?",
                    options: [
                        { text: "My voices assure me - we will reach the Dauphin safely.", response: "quest" },
                        { text: "I fear nothing but wrongdoing. God protects us.", response: "quest" }
                    ]
                },
                quest: "Survive the journey - Defeat 3 English patrol leaders",
                objective: { type: "leaders", count: 3 },
                historicalQuote: "I knew the way to Chinon because my voices told me... I traveled both day and night. My companions sometimes wanted me to rest, but I pressed on, telling them, 'God will give me strength.' We passed through many dangers. ‚Äî Joan's testimony, recorded by notary Guillaume Manchon, 1431",
                scholarlyQuote: "The journey from Vaucouleurs to Chinon was approximately 300 miles through hostile territory. Joan and her six-man escort traveled primarily at night to avoid detection. Jean de Metz later testified that Joan's companions were initially doubtful, but her confidence and piety convinced them. She attended Mass whenever possible and constantly urged the men onward with declarations that God was leading them. Against all odds, they arrived at Chinon on February 23, 1429, having spent eleven days in transit. ‚Äî Helen Castor, 'Joan of Arc: A History', Faber and Faber, 2014",
                nextChapter: 4
            },
            {
                title: "Chapter 5: Examination at Poitiers - March 1429",
                text: "Before Charles will trust Joan with an army, she must be examined by theologians and church scholars at Poitiers. For three weeks, learned doctors question her faith, her voices, and her mission. She must prove her divine calling not through battle, but through wisdom and faith.",
                location: "Poitiers",
                gameplay: "church",
                dialogue: {
                    speaker: "Brother Seguin (Dominican Theologian)",
                    text: "You say God sends you to drive out the English. But if God wishes to deliver France, He has no need of soldiers. Why do you require an army?",
                    options: [
                        { text: "The soldiers will fight, and God will give the victory!", response: "quest" },
                        { text: "In God's name, we must act. Prayer and action together serve His will.", response: "quest" }
                    ]
                },
                quest: "Withstand theological examination - Pray and reflect 3 times to demonstrate your faith",
                objective: { type: "prayers", count: 3 },
                historicalQuote: "You say that God wishes to deliver the people of France from their present calamity. If He wishes to deliver them, it is not necessary to have soldiers. ‚Äî Brother Seguin questioned me in this manner. I answered him: 'In God's name, the soldiers will fight, and God will give the victory!' The doctors were well satisfied with this answer. They found no evil in me. I was examined for three weeks by the clerks of Poitiers. ‚Äî Joan's testimony about her examination, recorded 1431",
                scholarlyQuote: "The examination at Poitiers was a crucial turning point. For three weeks in March 1429, Joan was interrogated by a commission of theologians, bishops, and scholars. They questioned her about the nature of her voices, her claim to divine mission, and whether she was heretical or deluded. The commission included some of the most learned men in France. Joan defended herself with remarkable intelligence and theological sophistication for an illiterate peasant girl. Her answers were deemed orthodox, her character beyond reproach, and her mission potentially genuine. The commission's favorable report gave Charles VII the religious authorization he needed to entrust Joan with military command. The report stated: 'The King should not prevent her from going to Orl√©ans with soldiers, but should have her led there honorably, trusting in God.' This examination demonstrated Joan's intelligence and conviction as much as any military victory later would. ‚Äî Nadia Margolis, 'Joan of Arc in History, Literature, and Film', Garland Publishing, 1990",
                nextChapter: 5
            },
            {
                title: "Chapter 6: The Siege of Orl√©ans - May 1429",
                text: "Joan arrives at Orl√©ans, besieged by the English for seven months. Against the advice of experienced commanders, she leads a direct assault. Wounded by an arrow between neck and shoulder, she returns to battle and achieves impossible victory.",
                location: "Orl√©ans",
                dialogue: {
                    speaker: "Jean d'Orl√©ans (Duke)",
                    text: "The English fortifications are impregnable. We have lost hundreds trying to break them. What can you do that we have not?",
                    options: [
                        { text: "I will enter the fortress before the sun sets. God wills it!", response: "quest" },
                        { text: "The soldiers will fight with renewed faith. Victory is assured.", response: "quest" }
                    ]
                },
                quest: "Break the siege - Defeat 5 English fortress commanders",
                objective: { type: "leaders", count: 5 },
                historicalQuote: "In the name of God, the soldiers will fight and God will give victory... On Friday, May 6th, I was wounded by an arrow which entered between my neck and shoulder, to the depth of half a foot. But I did not leave the field, and my wound was dressed. And afterward I returned to the attack. The fortress was taken, and the English fled. ‚Äî Joan's letter to the citizens of Tournai, June 1429",
                scholarlyQuote: "The liberation of Orl√©ans stands as Joan's most celebrated military achievement. When she arrived on April 29, 1429, the city had been under siege for seven months. The English held a ring of fortifications around the city, and previous French relief attempts had failed. Joan's strategy was remarkably direct: frontal assault on the English bastilles. On May 7, during the assault on Les Tourelles, an arrow pierced her shoulder. After having the wound dressed, she returned to lead the final charge. By May 8, the English had abandoned the siege. This victory, accomplished in just nine days, transformed Joan from an obscure peasant into a national symbol and military leader. ‚Äî Deborah Fraioli, 'Joan of Arc: The Early Debate', The Boydell Press, 2000",
                nextChapter: 6
            },
            {
                title: "Chapter 7: The March to Reims - Summer 1429",
                text: "Following her stunning victory at Orl√©ans, Joan leads the French army on an audacious campaign to Reims. City after city falls or surrenders as word of 'The Maid' spreads. The impossible becomes reality.",
                location: "Loire Valley",
                gameplay: "church",
                dialogue: {
                    speaker: "Charles VII",
                    text: "Joan, you have given France hope. But Reims lies deep in enemy territory. Can we truly reach it for my coronation?",
                    options: [
                        { text: "Before mid-summer, you WILL be crowned at Reims. This I promise.", response: "quest" },
                        { text: "Your Majesty, my voices have shown me your coronation. It will come to pass.", response: "quest" }
                    ]
                },
                quest: "Clear the path to Reims - Defeat 30 enemy soldiers, then pray at a liberated church",
                objective: { type: "both", kills: 30, prayers: 1 },
                historicalQuote: "The Dauphin is on his way to the city of Reims, where he will shortly receive his holy coronation... All the cities are surrendering to the King. I have seen such things as I never saw before; people come in crowds to meet him and cry for joy. ‚Äî Joan's letter, July 1429, recorded by Jean Pasquerel, her chaplain",
                scholarlyQuote: "The Loire Campaign and march to Reims constituted Joan's strategic masterpiece. Between May and July 1429, the French army captured Jargeau, Meung-sur-Loire, Beaugency, and won the Battle of Patay. This rapid success created a psychological momentum that proved as important as military victory. Towns that had resisted French control for years surrendered without a fight upon hearing that Joan approached. On July 16, 1429, after a campaign lasting just two months, Charles VII and his army entered Reims. The seemingly impossible had been achieved. ‚Äî Malcolm Vale, 'Charles VII', University of California Press, 1974",
                nextChapter: 7
            },
            {
                title: "Chapter 8: The Coronation - July 17, 1429",
                text: "Joan stands in Reims Cathedral as Charles VII is anointed and crowned King of France. She has fulfilled the primary mission given to her by her voices. Weeping with joy, she tells the King her task is complete.",
                location: "Reims Cathedral",
                gameplay: "church",
                dialogue: {
                    speaker: "King Charles VII",
                    text: "Joan, you have given me my kingdom. All of France celebrates this day. What reward can I give you?",
                    options: [
                        { text: "I ask only that you govern well and defend your people, Your Majesty.", response: "quest" },
                        { text: "My reward is seeing God's will fulfilled. France has her rightful King.", response: "quest" }
                    ]
                },
                quest: "Attend the coronation ceremony - Pray and give thanks in the cathedral",
                objective: { type: "prayers", count: 3 },
                historicalQuote: "At the coronation at Reims, when the King was crowned and consecrated, I stood near him with my standard in my hand. It was right that my standard should be present at the honor, since it had shared in the hardship... And there were tears in my eyes. My mission from God was accomplished. ‚Äî Joan's testimony, Trial of Condemnation, March 1431",
                scholarlyQuote: "The coronation took place in Reims Cathedral on July 17, 1429, barely five months after Joan's arrival at Chinon. Contemporary chroniclers describe an emotional scene: Joan stood near the altar holding her battle standard while Charles was anointed with holy oil and crowned. After the ceremony, she knelt before him weeping, calling him 'gentle King.' Her mission, as commanded by her voices, was complete. She had driven the English from Orl√©ans and brought the Dauphin to Reims for his sacred coronation. From this moment, Charles VII was the legitimate King of France in the eyes of God and man. ‚Äî Colette Beaune, 'Joan of Arc: A Biography', Yale University Press, 2008",
                nextChapter: 8
            },
            {
                title: "Chapter 9: The Siege of Paris - September 1429",
                text: "Despite fulfilling her divine mission, Joan continues fighting. She urges an assault on Paris to complete France's liberation. Against her advice, the attack is poorly supported. Joan is wounded by a crossbow bolt in the thigh.",
                location: "Paris",
                dialogue: {
                    speaker: "Georges de La Tr√©moille (Royal Advisor)",
                    text: "The King wishes to negotiate with the Burgundians. We should not risk another assault on Paris, Joan.",
                    options: [
                        { text: "Paris must be liberated! We have momentum - we must not stop now!", response: "quest" },
                        { text: "My voices tell me we must press forward. Do not let politics defeat us.", response: "quest" }
                    ]
                },
                quest: "Attempt to take Paris - Defeat 25 defenders (you will be wounded but survive)",
                objective: { type: "kills", count: 25 },
                historicalQuote: "I was wounded in the assault on Paris by a crossbow bolt in the thigh. I remained in the ditch until nightfall, but finally I was forced to withdraw. I cried out to the soldiers, 'Do not leave! The fortress will be yours!' But the King ordered a retreat... I wept bitterly that night. ‚Äî Recorded by witnesses, September 8, 1429",
                scholarlyQuote: "The assault on Paris, launched on September 8, 1429, marked the beginning of Joan's decline. Political factions at court, particularly led by Georges de La Tr√©moille, feared Joan's growing influence and advocated for negotiation rather than continued military action. The attack was undertaken with insufficient forces and was poorly coordinated. Joan was shot in the thigh with a crossbow bolt but refused to leave the field until nightfall. The next day, Charles VII ordered a complete withdrawal and disbanded much of the army. For Joan, who believed her voices urged her to continue fighting, this was a devastating betrayal. ‚Äî Fran√ßoise Michaud-Fr√©javille, 'Joan of Arc at the Court of Charles VII', Medieval Warfare Magazine, 2013",
                nextChapter: 9
            },
            {
                title: "Chapter 10: Capture at Compi√®gne - May 23, 1430",
                text: "Nearly a year after her greatest triumph, Joan is captured during a skirmish at Compi√®gne. Pulled from her horse by Burgundian soldiers, she becomes a prisoner. King Charles VII makes no attempt to ransom her.",
                location: "Compi√®gne",
                dialogue: {
                    speaker: "Burgundian Captain",
                    text: "The famous Maid of Orl√©ans, captured at last! The English will pay a fortune for you, witch!",
                    options: [
                        { text: "I am no witch! I serve God and France!", response: "quest" },
                        { text: "Do what you will. My King will ransom me... he must...", response: "quest" }
                    ]
                },
                quest: "Fight to the last - Defeat 20 Burgundian soldiers before capture (this chapter ends in capture - you cannot win)",
                objective: { type: "kills", count: 20 },
                historicalQuote: "On May 23rd, I was taken prisoner at Compi√®gne. I was in the rearguard protecting the retreat when I was pulled from my horse. The Burgundians held me... I asked my voices many times if I would be burned. They answered, 'Take everything in good part; do not be concerned about your martyrdom. From it you will come at last to the Kingdom of Paradise.' ‚Äî Joan's testimony, Trial of Condemnation, May 1431",
                scholarlyQuote: "Joan was captured on May 23, 1430, during a sortie from the besieged town of Compi√®gne. While covering a retreat, she was surrounded and pulled from her horse by archers in the service of Jean de Luxembourg, a Burgundian captain. She was immediately recognized and taken prisoner. The Burgundians knew her capture was valuable: the English were desperate to discredit her and would pay handsomely. Most devastating was that Charles VII, the king she had crowned, made no serious effort to ransom her, despite having successfully ransomed numerous lesser nobles. Joan was sold to the English for 10,000 livres. ‚Äî Jules Michelet, 'Joan of Arc', University of Michigan Press, 1957 (translation of 1853 original)",
                nextChapter: -1
            }
        ];
        
        // Alexander the Great Story Mode - Major historical battles
        const alexanderChapters = [
            {
                title: "Chapter 1: Ascension - 336 BC",
                text: "At age 20, Alexander becomes king of Macedonia after his father Philip II's assassination. He must first secure his throne by crushing rebellions in Thebes and establishing his authority. The young king who studied under Aristotle now faces his first test of leadership.",
                location: "Thebes, Greece",
                dialogue: {
                    speaker: "Parmenion (Senior General)",
                    text: "The Thebans have revolted, my King. They believe you are too young and inexperienced. Many doubt you can hold your father's empire together.",
                    options: [
                        { text: "They will learn that Alexander is no mere boy!", response: "quest" },
                        { text: "I will show them the same resolve my father had - and more!", response: "quest" }
                    ]
                },
                quest: "Crush the Theban revolt - Defeat 25 Theban warriors and 3 leaders",
                objective: { type: "both", kills: 25, leaders: 3 },
                historicalNote: "Alexander razed Thebes to the ground, sparing only temples and the house of the poet Pindar. This brutal act sent a message to all of Greece: the young king was not to be trifled with.",
                nextChapter: 1
            },
            {
                title: "Chapter 2: The Battle of Granicus - 334 BC",
                text: "Crossing into Asia Minor with 37,000 men, Alexander faces his first major test against the Persian forces at the Granicus River. Against his generals' advice, he orders a frontal assault across the river. During the battle, Alexander is saved from death when Cleitus the Black cuts down a Persian nobleman about to kill him.",
                location: "Granicus River, Asia Minor",
                dialogue: {
                    speaker: "Parmenion (Senior General)",
                    text: "My King, the Persians hold the high ground. We should wait until morning and find a better crossing. This frontal assault is too dangerous!",
                    options: [
                        { text: "Fortune favors the bold! We attack now!", response: "quest" },
                        { text: "Today we show the Persians the might of Macedonia!", response: "quest" }
                    ]
                },
                quest: "Charge across the river - Defeat 30 Persian soldiers and 3 commanders",
                objective: { type: "both", kills: 30, leaders: 3 },
                historicalNote: "This victory opened all of Asia Minor to Alexander. He personally led the cavalry charge and nearly died in single combat. His conquest of the Persian Empire had begun.",
                nextChapter: 2
            },
            {
                title: "Chapter 3: The Battle of Issus - 333 BC",
                text: "King Darius III of Persia himself takes the field with over 100,000 men. At the narrow coastal plain of Issus, Alexander's smaller force of 40,000 faces the Great King. During the battle, Alexander charges directly at Darius, who flees the battlefield, abandoning his mother, wife, and children.",
                location: "Issus, Cilicia",
                dialogue: {
                    speaker: "Darius III (Persian King)",
                    text: "I offer you peace, Alexander. Take all lands west of the Euphrates, marry my daughter, and be content with what you have conquered! Why risk everything?",
                    options: [
                        { text: "I am already lord of all you offer, Darius. Soon I shall have all you possess!", response: "quest" },
                        { text: "There cannot be two suns in the sky, nor two kings on earth!", response: "quest" }
                    ]
                },
                quest: "Break the Persian center - Defeat 40 Persian warriors and 4 commanders",
                objective: { type: "both", kills: 40, leaders: 4 },
                historicalNote: "After the battle, Alexander treated Darius's captured family with respect and honor. Darius's mother, Sisygambis, was so impressed she later mourned Alexander more than her own son.",
                nextChapter: 3
            },
            {
                title: "Chapter 4: The Siege of Tyre - 332 BC",
                text: "The island fortress-city of Tyre refuses to submit, trusting in its position half a mile offshore. Alexander accomplishes the impossible: building a causeway across the sea using the ruins of old Tyre. The siege lasts seven months. When the city finally falls, Alexander sells 30,000 Tyrians into slavery as punishment for their defiance.",
                location: "Tyre, Phoenicia",
                dialogue: {
                    speaker: "Engineers Commander",
                    text: "Sire, no army has ever taken Tyre by land. Their walls rise from the sea itself. The Tyrian navy dominates these waters. How can we possibly bridge half a mile of ocean?",
                    options: [
                        { text: "We shall make the sea our battlefield! Begin construction immediately!", response: "quest" },
                        { text: "What man has built, man can conquer! I will not leave until Tyre is mine!", response: "quest" }
                    ]
                },
                quest: "Storm the island fortress - Defeat 35 Tyrian defenders and 3 commanders",
                objective: { type: "both", kills: 35, leaders: 3 },
                historicalNote: "The causeway Alexander built still exists today, having permanently connected Tyre to the mainland. This engineering marvel demonstrated that Alexander would let nothing stand in his way.",
                nextChapter: 4
            },
            {
                title: "Chapter 5: Egypt and the Oracle - 332-331 BC",
                text: "Egypt welcomes Alexander as a liberator from Persian rule. He founds the city of Alexandria, destined to become the greatest city of the ancient world. At the Oracle of Siwa, deep in the desert, Alexander is proclaimed the son of Zeus-Ammon, confirming his divine destiny.",
                location: "Siwa Oasis, Egypt",
                dialogue: {
                    speaker: "Oracle of Siwa",
                    text: "Hail, son of Zeus-Ammon! The gods recognize you as divine! What question do you bring to the oracle of the desert?",
                    options: [
                        { text: "Will I conquer the entire world?", response: "quest" },
                        { text: "Am I truly the son of a god?", response: "quest" }
                    ]
                },
                quest: "Defend the oracle from bandits - Defeat 20 desert raiders and 2 leaders",
                objective: { type: "both", kills: 20, leaders: 2 },
                historicalNote: "From this point forward, Alexander increasingly saw himself as divine. He founded over 20 cities named Alexandria across his empire, spreading Greek culture throughout the known world.",
                nextChapter: 5
            },
            {
                title: "Chapter 6: The Battle of Gaugamela - 331 BC",
                text: "On the carefully prepared plains of Gaugamela, Darius assembles the greatest army ever seen - perhaps 250,000 men with war elephants, scythed chariots, and cavalry from across the Persian Empire. Alexander commands only 47,000. This is the decisive battle that will determine the fate of two empires.",
                location: "Gaugamela, Mesopotamia",
                dialogue: {
                    speaker: "Parmenion (Senior General)",
                    text: "My King, their numbers are overwhelming. They outnumber us five to one. We are completely surrounded! Should we attack at night when their numbers mean less?",
                    options: [
                        { text: "I will not steal victory like a thief! We fight at dawn!", response: "quest" },
                        { text: "Better to fight surrounded - they cannot escape us! We attack!", response: "quest" }
                    ]
                },
                quest: "Shatter the Persian Empire - Defeat 50 Persian warriors and 5 commanders",
                objective: { type: "both", kills: 50, leaders: 5 },
                historicalNote: "Alexander's brilliant tactics won the day. Darius fled again, and was later murdered by his own men. Alexander became Lord of Asia, ruler of the greatest empire the world had seen.",
                nextChapter: 6
            },
            {
                title: "Chapter 7: The Death of Cleitus - 328 BC",
                text: "At a drunken banquet in Samarkand, Alexander quarrels with Cleitus the Black, the man who once saved his life. In a rage, Alexander kills his loyal friend with a spear. Overcome with remorse, Alexander locks himself in his tent for three days, refusing food and water, contemplating suicide.",
                location: "Samarkand, Sogdiana",
                dialogue: {
                    speaker: "Cleitus the Black",
                    text: "You call yourself son of Zeus-Ammon! You forget it was Philip who built this army! You forget it was I who saved your life at Granicus when you charged ahead like a fool!",
                    options: [
                        { text: "How dare you speak to me this way! I am your King!", response: "quest" },
                        { text: "You were brave once, Cleitus, but now you are just a drunk!", response: "quest" }
                    ]
                },
                quest: "Face assassination attempts from within - Defeat 15 conspirators and 2 traitorous officers",
                objective: { type: "both", kills: 15, leaders: 2 },
                historicalNote: "This tragedy marked a turning point. Alexander's adoption of Persian customs and claim to divinity alienated many of his Macedonian veterans. The seeds of mutiny were planted.",
                nextChapter: 7
            },
            {
                title: "Chapter 8: The Battle of Hydaspes - 326 BC",
                text: "At the Hydaspes River in India, Alexander faces King Porus and his terrifying war elephants. In a monsoon, Alexander executes a brilliant night crossing of the swollen river. After the battle, impressed by Porus's courage, Alexander allows him to keep his kingdom and adds his territory to the empire.",
                location: "Hydaspes River, India",
                dialogue: {
                    speaker: "King Porus of India",
                    text: "You have defeated me, Alexander. I am a king, born of kings. Tell me, how should a king be treated by another king?",
                    options: [
                        { text: "Like a king, for you fought like one! Rule your lands in my name!", response: "quest" },
                        { text: "With honor and respect! The brave deserve mercy, not chains!", response: "quest" }
                    ]
                },
                quest: "Defeat the war elephants - Defeat 45 warriors and 5 commanders",
                objective: { type: "both", kills: 45, leaders: 5 },
                historicalNote: "This was Alexander's last major battle. His exhausted army mutinied at the Hyphasis River, refusing to march further east. Alexander wept but turned back, his dream of reaching the edge of the world unfulfilled.",
                nextChapter: 8
            },
            {
                title: "Chapter 9: The Return - 325-323 BC",
                text: "The march back through the Gedrosian Desert costs Alexander more men than all his battles combined. He returns to Babylon, planning new conquests of Arabia. But at age 32, after a prolonged banquet, Alexander falls ill with a fever. Within days, the greatest conqueror in history is dead, his empire fragmenting immediately.",
                location: "Babylon",
                dialogue: {
                    speaker: "Perdiccas (General)",
                    text: "Great King, you burn with fever. You must rest! Who will inherit your empire? To whom do you leave this vast realm you have built?",
                    options: [
                        { text: "To the strongest! Let them prove themselves worthy!", response: "quest" },
                        { text: "My empire will not fall. I shall rise again and conquer more!", response: "quest" }
                    ]
                },
                quest: "Final defense of Babylon - Hold the palace against 30 attackers and 3 enemy generals",
                objective: { type: "both", kills: 30, leaders: 3 },
                historicalNote: "Alexander died June 10 or 11, 323 BC. His empire immediately split among his generals (the Diadochi), leading to 40 years of war. He left no clear heir, having conquered the world but failed to secure succession.",
                nextChapter: -1
            }
        ];
        
        
        // Audio Setup
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic = null;
        
        // Stage environment manager - will be initialized after scene is created
        let currentStage = 'battlefield';
        let stageObjects = [];
        
        // Generate church organ background music (uncopyrighted procedural music)
        function createChurchMusic() {
            const duration = 60; // 60 seconds - full beautiful composition
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(2, duration * sampleRate, sampleRate);
            
            // Beautiful baroque-style chord progression inspired by Pachelbel's Canon
            // Each measure is 4 seconds for slow, reverent pacing
            const measures = [
                // Opening (0-16s) - Classic I-V-vi-iii-IV-I-IV-V progression
                { time: 0, chords: [261.63, 329.63, 392.00, 523.25] },    // C major - I
                { time: 4, chords: [392.00, 493.88, 587.33, 783.99] },    // G major - V
                { time: 8, chords: [220.00, 277.18, 329.63, 440.00] },    // A minor - vi
                { time: 12, chords: [164.81, 207.65, 246.94, 329.63] },   // E minor - iii
                
                // Development (16-32s)
                { time: 16, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 20, chords: [261.63, 329.63, 392.00, 523.25] },   // C major - I
                { time: 24, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 28, chords: [392.00, 493.88, 587.33, 783.99] },   // G major - V
                
                // Middle section (32-48s) - Rich modulation
                { time: 32, chords: [220.00, 277.18, 329.63, 440.00] },   // A minor - vi
                { time: 36, chords: [174.61, 220.00, 261.63, 349.23] },   // F major - IV
                { time: 40, chords: [261.63, 329.63, 392.00, 523.25] },   // C major - I
                { time: 44, chords: [392.00, 493.88, 587.33, 783.99] },   // G major - V
                
                // Grand finale (48-60s) - Return home with suspension
                { time: 48, chords: [220.00, 277.18, 329.63, 440.00] },   // A minor - vi
                { time: 52, chords: [196.00, 246.94, 293.66, 392.00] },   // G major sus - V
                { time: 56, chords: [261.63, 329.63, 392.00, 523.25] }    // C major - I (final)
            ];
            
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;
                    
                    // Find current measure
                    let currentMeasure = measures[0];
                    for (let m = 0; m < measures.length; m++) {
                        if (t >= measures[m].time) {
                            currentMeasure = measures[m];
                        }
                    }
                    
                    const frequencies = currentMeasure.chords;
                    
                    // Rich organ voicing with multiple ranks (inspired by Bach's registrations)
                    for (let f = 0; f < frequencies.length; f++) {
                        const freq = frequencies[f];
                        
                        // Principal 8' (fundamental)
                        sample += Math.sin(2 * Math.PI * freq * t) * 0.20;
                        
                        // Octave 4' (first harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 2 * t) * 0.12;
                        
                        // Quint 2 2/3' (third harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 3 * t) * 0.08;
                        
                        // Super Octave 2' (fourth harmonic)
                        sample += Math.sin(2 * Math.PI * freq * 4 * t) * 0.05;
                        
                        // Sub Bass 16' (pedal tone)
                        if (f === 0) { // Only on bass note
                            sample += Math.sin(2 * Math.PI * freq * 0.5 * t) * 0.15;
                        }
                        
                        // Tierce 1 3/5' (fifth harmonic - adds brilliance)
                        sample += Math.sin(2 * Math.PI * freq * 5 * t) * 0.03;
                    }
                    
                    // Baroque-style ornamentation (inspired by Bach's preludes)
                    const ornamentFreq = 4; // Slow trill/vibrato
                    const ornament = Math.sin(2 * Math.PI * ornamentFreq * t) * 0.004;
                    sample *= (1 + ornament);
                    
                    // Dynamic expression (crescendo and diminuendo like a real organist)
                    let expression = 1.0;
                    const measureProgress = (t % 4) / 4; // Position within measure
                    
                    // Slight swell at measure midpoint
                    expression = 0.85 + Math.sin(measureProgress * Math.PI) * 0.15;
                    
                    // Overall dynamics (forte -> piano -> forte)
                    let overallDynamics = 1.0;
                    if (t < 16) {
                        overallDynamics = 0.9; // Opening - moderately loud
                    } else if (t < 32) {
                        overallDynamics = 1.0; // Development - full
                    } else if (t < 48) {
                        overallDynamics = 0.85; // Middle - softer
                    } else {
                        overallDynamics = 1.0; // Finale - full again
                    }
                    
                    // Smooth transitions between chords (legato style)
                    let transitionEnvelope = 1.0;
                    const timeInMeasure = t % 4;
                    if (timeInMeasure < 0.1) {
                        transitionEnvelope = timeInMeasure / 0.1; // Quick attack
                    } else if (timeInMeasure > 3.8) {
                        transitionEnvelope = (4 - timeInMeasure) / 0.2; // Smooth release
                    }
                    
                    // Grand loop envelope
                    let loopEnvelope = 1.0;
                    const fadeTime = 2.0;
                    if (t < fadeTime) {
                        loopEnvelope = Math.pow(t / fadeTime, 0.5); // Smooth fade in
                    } else if (t > duration - fadeTime) {
                        loopEnvelope = Math.pow((duration - t) / fadeTime, 0.5); // Smooth fade out
                    }
                    
                    // Final mix with stereo width (slight delay for cathedral ambience)
                    const stereoDelay = (channel === 1) ? Math.sin(2 * Math.PI * 0.5 * t) * 0.02 : 0;
                    
                    data[i] = sample * expression * overallDynamics * transitionEnvelope * loopEnvelope * 0.28 * (1 + stereoDelay);
                }
            }
            
            return buffer;
        }
        
        function createActionMovieMusic() {
            const duration = 60; // 60 seconds metal rock
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(2, duration * sampleRate, sampleRate);
            
            // Metal rock power chord progression - aggressive and heavy
            const measures = [
                // Intro riff (0-16s) - Heavy power chords
                { time: 0, root: 110.00, intensity: 1.0 },    // A power chord
                { time: 2, root: 98.00, intensity: 0.95 },    // G power chord
                { time: 4, root: 87.31, intensity: 1.05 },    // F power chord
                { time: 6, root: 110.00, intensity: 1.0 },    // A power chord
                { time: 8, root: 116.54, intensity: 1.1 },    // A# power chord
                { time: 10, root: 110.00, intensity: 1.05 },  // A power chord
                { time: 12, root: 98.00, intensity: 1.0 },    // G power chord
                { time: 14, root: 130.81, intensity: 1.15 },  // C power chord
                
                // Verse (16-32s) - Driving rhythm
                { time: 16, root: 110.00, intensity: 1.1 },   // A
                { time: 18, root: 110.00, intensity: 1.15 },  // A
                { time: 20, root: 146.83, intensity: 1.1 },   // D
                { time: 22, root: 130.81, intensity: 1.05 },  // C
                { time: 24, root: 110.00, intensity: 1.2 },   // A
                { time: 26, root: 98.00, intensity: 1.15 },   // G
                { time: 28, root: 146.83, intensity: 1.1 },   // D
                { time: 30, root: 110.00, intensity: 1.2 },   // A
                
                // Chorus (32-48s) - Maximum intensity
                { time: 32, root: 164.81, intensity: 1.3 },   // E power chord - epic
                { time: 34, root: 146.83, intensity: 1.25 },  // D
                { time: 36, root: 110.00, intensity: 1.3 },   // A
                { time: 38, root: 164.81, intensity: 1.35 },  // E
                { time: 40, root: 146.83, intensity: 1.3 },   // D
                { time: 42, root: 130.81, intensity: 1.25 },  // C
                { time: 44, root: 110.00, intensity: 1.35 },  // A
                { time: 46, root: 98.00, intensity: 1.3 },    // G
                
                // Outro (48-60s) - Return to main riff
                { time: 48, root: 110.00, intensity: 1.2 },   // A
                { time: 50, root: 98.00, intensity: 1.15 },   // G
                { time: 52, root: 87.31, intensity: 1.1 },    // F
                { time: 54, root: 110.00, intensity: 1.15 },  // A
                { time: 56, root: 116.54, intensity: 1.2 },   // A#
                { time: 58, root: 110.00, intensity: 1.1 }    // A
            ];
            
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;
                    
                    // Find current measure
                    let currentMeasure = measures[0];
                    for (let m = 0; m < measures.length; m++) {
                        if (t >= measures[m].time) {
                            currentMeasure = measures[m];
                        }
                    }
                    
                    const root = currentMeasure.root;
                    const intensity = currentMeasure.intensity;
                    
                    // === ELECTRIC GUITAR - Distorted power chords ===
                    // Root note (fundamental)
                    let guitar = Math.sin(2 * Math.PI * root * t);
                    // Perfect fifth (power chord)
                    guitar += Math.sin(2 * Math.PI * root * 1.5 * t) * 0.8;
                    // Octave
                    guitar += Math.sin(2 * Math.PI * root * 2 * t) * 0.6;
                    
                    // Distortion effect (clipping for metal sound)
                    guitar *= 1.8;
                    if (guitar > 1) guitar = 1;
                    if (guitar < -1) guitar = -1;
                    
                    // Add harmonics for metallic guitar tone
                    guitar += Math.sin(2 * Math.PI * root * 3 * t) * 0.15;
                    guitar += Math.sin(2 * Math.PI * root * 4 * t) * 0.1;
                    
                    // Palm mute effect (rhythmic chugging)
                    const palmMute = Math.abs(Math.sin(2 * Math.PI * 4 * t)); // 4 hits per second
                    guitar *= (0.3 + palmMute * 0.7);
                    
                    sample += guitar * 0.35 * intensity;
                    
                    // === BASS GUITAR - Deep and punchy ===
                    let bass = Math.sin(2 * Math.PI * root * 0.5 * t); // One octave down
                    bass += Math.sin(2 * Math.PI * root * 0.5 * 2 * t) * 0.4; // Octave harmonic
                    
                    // Bass follows kick drum pattern
                    const beatTime = t * 2.5; // 150 BPM
                    const beatPhase = beatTime % 1;
                    if (beatPhase < 0.1) {
                        bass *= 1.5; // Accent on beat
                    }
                    
                    sample += bass * 0.25 * intensity;
                    
                    // === NO DRUMS - Pure guitar and bass ===
                    // Drums removed to eliminate metronome sound
                    
                    // === Overall mix and dynamics ===
                    // Rock compression (make loud parts louder, maintain energy)
                    let overallDynamics = intensity;
                    if (t < 16) {
                        overallDynamics *= 0.9; // Intro
                    } else if (t >= 32 && t < 48) {
                        overallDynamics *= 1.1; // Chorus boost
                    }
                    
                    // Smooth chord transitions
                    const timeInChord = t % 2;
                    let transitionEnvelope = 1.0;
                    if (timeInChord < 0.05) {
                        transitionEnvelope = timeInChord / 0.05;
                    }
                    
                    // Loop envelope for seamless repeat
                    let loopEnvelope = 1.0;
                    const fadeTime = 2.0;
                    if (t < fadeTime) {
                        loopEnvelope = t / fadeTime;
                    } else if (t > duration - fadeTime) {
                        loopEnvelope = (duration - t) / fadeTime;
                    }
                    
                    // Stereo spread for guitar (wider on right channel)
                    const stereoSpread = (channel === 1) ? 1.1 : 0.9;
                    
                    data[i] = sample * overallDynamics * transitionEnvelope * loopEnvelope * 0.32 * stereoSpread;
                }
            }
            
            return buffer;
        }
        
        function playBackgroundMusic() {
            if (backgroundMusic) return;
            
            // Choose music based on game mode - default to church music if mode not set
            let buffer;
            try {
                buffer = (gameState && gameState.mode === 'gun') ? createActionMovieMusic() : createChurchMusic();
            } catch (e) {
                console.error('Music creation error:', e);
                buffer = createChurchMusic(); // Fallback to church music
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0.30; // 30% volume for background music
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start(0);
            
            backgroundMusic = source;
        }
        
        // Sword slash sound - DISABLED (silent)
        function playSwordSlashSound() {
            // Sound effect disabled per user request
            return;
        }
        
        // Divine special attack sound
        function playDivineSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // 5% volume
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        // Healing prayer sound
        function playHealSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C note
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E note
            oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G note
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // 5% volume
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        // Hit impact sound
        function playHitSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // 5% volume
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Gun shot sound
        function playGunSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(120, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.05);
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // 5% volume
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
        }

        // Game State
        const gameState = {
            mode: null,
            health: 100,
            maxHealth: 100,
            special: 100,
            maxSpecial: 100,
            kills: 0,
            prayers: 0,
            combo: 0,
            comboTimer: null,
            comboHits: 0,
            allies: [],
            enemies: [],
            leaders: [],
            isAttacking: false,
            gameStarted: false,
            readyToPlay: false,
            prayTarget: null,
            leadersDefeated: 0,
            totalLeaders: 5,
            gameWon: false,
            currentChapter: 0,
            questActive: false,
            questComplete: false,
            nextAction: null,
            pendingChapter: null
        };

        const mobileControls = {
            joystick: { active: false, x: 0, y: 0 },
            moveVector: { x: 0, z: 0 }
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xA8D8A8); // Light green sky for grass field ambiance
        scene.fog = new THREE.Fog(0xB8E6B8, 60, 280); // Light green fog for grass fields

        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 18, 28);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xB8E6B8, 0.75); // Light green ambient
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xFFFAE6, 1.2); // Warm sunlight
        sunLight.position.set(70, 60, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xD4EED4, 0.5); // Green fill light
        fillLight.position.set(-50, 40, -40);
        scene.add(fillLight);

        const hemiLight = new THREE.HemisphereLight(0xA8D8A8, 0x4a7d35, 0.85); // Green sky, green ground
        scene.add(hemiLight);

        // Green Grassy Ground
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Brighter base green
            ctx.fillStyle = '#5a9d45';
            ctx.fillRect(0, 0, 512, 512);
            
            for (let i = 0; i < 12000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const greenShade = 90 + Math.random() * 60; // Brighter greens
                const grassType = Math.random();
                
                if (grassType < 0.7) {
                    // Vibrant light green
                    ctx.fillStyle = `rgba(${greenShade * 0.6}, ${greenShade * 1.1}, ${greenShade * 0.5}, ${0.5 + Math.random() * 0.3})`;
                } else {
                    // Rich medium green
                    ctx.fillStyle = `rgba(${greenShade * 0.4}, ${greenShade * 0.9}, ${greenShade * 0.4}, ${0.6 + Math.random() * 0.3})`;
                }
                
                const size = Math.random() * 3;
                ctx.fillRect(x, y, size, size);
            }
            
            // Fewer dirt patches for greener appearance
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const brownShade = 80 + Math.random() * 40;
                ctx.fillStyle = `rgba(${brownShade}, ${brownShade * 0.7}, ${brownShade * 0.5}, 0.15)`;
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20);
            return texture;
        }

        const groundGeometry = new THREE.PlaneGeometry(250, 250, 80, 80);
        const grassTexture = createGrassTexture();
        const groundMaterial = new THREE.MeshPhongMaterial({ 
            map: grassTexture,
            color: 0x5a9d45, // Brighter, more vibrant green
            shininess: 3
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        
        const positions = ground.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const z = positions.getZ(i);
            let y = Math.sin(x * 0.015) * Math.cos(z * 0.015) * 3;
            y += Math.sin(x * 0.03) * Math.cos(z * 0.03) * 1.5;
            y += (Math.random() - 0.5) * 0.5;
            positions.setY(i, y);
        }
        positions.needsUpdate = true;
        ground.geometry.computeVertexNormals();
        scene.add(ground);

        // Grass tufts
        const grassTuftMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x3a6b2a,
            side: THREE.DoubleSide,
            flatShading: true
        });
        
        for (let i = 0; i < 200; i++) {
            const tuft = new THREE.Group();
            
            for (let j = 0; j < 10; j++) {
                const bladeGeometry = new THREE.ConeGeometry(0.04, 0.35 + Math.random() * 0.25, 3);
                const blade = new THREE.Mesh(bladeGeometry, grassTuftMaterial);
                blade.position.set(
                    (Math.random() - 0.5) * 0.4,
                    0.17,
                    (Math.random() - 0.5) * 0.4
                );
                blade.rotation.z = (Math.random() - 0.5) * 0.25;
                tuft.add(blade);
            }
            
            tuft.position.set(
                (Math.random() - 0.5) * 220,
                0,
                (Math.random() - 0.5) * 220
            );
            scene.add(tuft);
        }

        // Distant Castle
        const castle = new THREE.Group();
        const castleMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            flatShading: true
        });
        
        const keepGeometry = new THREE.BoxGeometry(18, 30, 18);
        const keep = new THREE.Mesh(keepGeometry, castleMaterial);
        keep.position.y = 15;
        keep.castShadow = true;
        castle.add(keep);
        
        for (let i = 0; i < 16; i++) {
            const merlonGeometry = new THREE.BoxGeometry(1.8, 2.5, 1.8);
            const merlon = new THREE.Mesh(merlonGeometry, castleMaterial);
            const angle = (i / 16) * Math.PI * 2;
            merlon.position.set(
                Math.cos(angle) * 9.5,
                31.5,
                Math.sin(angle) * 9.5
            );
            merlon.castShadow = true;
            castle.add(merlon);
        }
        
        const towerPositions = [[-12, 0, -12], [12, 0, -12], [-12, 0, 12], [12, 0, 12]];
        
        towerPositions.forEach(function(pos) {
            const towerGeometry = new THREE.CylinderGeometry(3.5, 4, 24, 16);
            const tower = new THREE.Mesh(towerGeometry, castleMaterial);
            tower.position.set(pos[0], 12, pos[2]);
            tower.castShadow = true;
            castle.add(tower);
            
            const roofGeometry = new THREE.ConeGeometry(4.8, 7, 16);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2a2a });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(pos[0], 27.5, pos[2]);
            roof.castShadow = true;
            castle.add(roof);
        });
        
        castle.position.set(-150, 0, -120);
        castle.scale.set(1.5, 1.5, 1.5);
        scene.add(castle);

        // Create Characters
        function createJoanWithGuns() {
            const joan = new THREE.Group();
            
            // Black trenchcoat torso
            const torsoGeometry = new THREE.CylinderGeometry(0.6, 0.85, 2.2, 16);
            const blackCoatMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a0a0a, // Very dark black
                shininess: 30,
                specular: 0x222222
            });
            const torso = new THREE.Mesh(torsoGeometry, blackCoatMaterial);
            torso.position.y = 2.5;
            torso.castShadow = true;
            joan.add(torso);
            
            // Black coat chest
            const chestGeometry = new THREE.CylinderGeometry(0.7, 0.85, 1.4, 16);
            const chest = new THREE.Mesh(chestGeometry, blackCoatMaterial);
            chest.position.y = 2.9;
            chest.castShadow = true;
            joan.add(chest);
            
            // Black shoulders
            const shoulderGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, blackCoatMaterial);
            leftShoulder.position.set(-0.95, 3.4, 0);
            leftShoulder.castShadow = true;
            joan.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, blackCoatMaterial);
            rightShoulder.position.set(0.95, 3.4, 0);
            rightShoulder.castShadow = true;
            joan.add(rightShoulder);
            
            // Black pants/legs
            const legGeometry = new THREE.CylinderGeometry(0.28, 0.3, 1.6, 12);
            const leftLeg = new THREE.Mesh(legGeometry, blackCoatMaterial);
            leftLeg.position.set(-0.32, 0.5, 0);
            leftLeg.castShadow = true;
            joan.add(leftLeg);
            joan.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, blackCoatMaterial);
            rightLeg.position.set(0.32, 0.5, 0);
            rightLeg.castShadow = true;
            joan.add(rightLeg);
            joan.rightLeg = rightLeg;
            
            // Black coat sleeves
            const armGeometry = new THREE.CylinderGeometry(0.24, 0.26, 1.9, 12);
            const leftArm = new THREE.Mesh(armGeometry, blackCoatMaterial);
            leftArm.position.set(-0.95, 2.5, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            joan.add(leftArm);
            joan.leftArm = leftArm;
            
            const rightArm = new THREE.Mesh(armGeometry, blackCoatMaterial);
            rightArm.position.set(0.95, 2.5, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            joan.add(rightArm);
            joan.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.55, 20, 20);
            const skinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD1A3,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 4.1;
            head.castShadow = true;
            joan.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.6, 18, 14, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 4.3;
            hair.castShadow = true;
            joan.add(hair);
            
            const glowGeometry = new THREE.SphereGeometry(1.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2.5;
            joan.add(glow);
            joan.glow = glow;
            
            // LEFT PISTOL (Handgun)
            const leftGunGroup = new THREE.Group();
            
            const leftBarrelGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8);
            const gunMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2a2a2a,
                shininess: 80,
                specular: 0x666666
            });
            const leftBarrel = new THREE.Mesh(leftBarrelGeometry, gunMaterial);
            leftBarrel.rotation.z = Math.PI / 2;
            leftBarrel.position.x = 0.3;
            leftBarrel.castShadow = true;
            leftGunGroup.add(leftBarrel);
            
            const leftGripGeometry = new THREE.BoxGeometry(0.12, 0.35, 0.08);
            const gripMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3020 });
            const leftGrip = new THREE.Mesh(leftGripGeometry, gripMaterial);
            leftGrip.position.set(0, -0.2, 0);
            leftGrip.rotation.z = -0.3;
            leftGrip.castShadow = true;
            leftGunGroup.add(leftGrip);
            
            leftGunGroup.position.set(-1.1, 2.3, 0.3);
            leftGunGroup.rotation.z = 0.3;
            joan.add(leftGunGroup);
            joan.leftGun = leftGunGroup;
            
            // RIGHT PISTOL (Handgun)
            const rightGunGroup = new THREE.Group();
            
            const rightBarrel = new THREE.Mesh(leftBarrelGeometry, gunMaterial);
            rightBarrel.rotation.z = Math.PI / 2;
            rightBarrel.position.x = 0.3;
            rightBarrel.castShadow = true;
            rightGunGroup.add(rightBarrel);
            
            const rightGrip = new THREE.Mesh(leftGripGeometry, gripMaterial);
            rightGrip.position.set(0, -0.2, 0);
            rightGrip.rotation.z = -0.3;
            rightGrip.castShadow = true;
            rightGunGroup.add(rightGrip);
            
            rightGunGroup.position.set(1.1, 2.3, 0.3);
            rightGunGroup.rotation.z = -0.3;
            joan.add(rightGunGroup);
            joan.rightGun = rightGunGroup;
            
            // Long black trenchcoat cape
            const capeGeometry = new THREE.BoxGeometry(1.8, 3.0, 0.1);
            const blackCapeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a0a0a,
                shininess: 15,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, blackCapeMaterial);
            cape.position.set(0, 1.8, -0.5);
            cape.castShadow = true;
            joan.add(cape);
            joan.cape = cape;
            
            const glowLight = new THREE.PointLight(0xFFFFFF, 0.5, 10);
            glowLight.position.y = 4;
            joan.add(glowLight);
            joan.glowLight = glowLight;
            
            joan.position.set(0, 0, 0);
            joan.health = gameState.maxHealth;
            joan.isPlayer = true;
            joan.walkCycle = 0;
            joan.direction = 0;
            joan.hasGuns = true;
            
            return joan;
        }

        function createJoan() {
            const joan = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4169E1,
                shininess: 100,
                specular: 0x6495ED
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.5;
            torso.castShadow = true;
            joan.add(torso);
            
            const chestGeometry = new THREE.CylinderGeometry(0.7, 0.8, 1.2, 16);
            const goldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 120,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, goldMaterial);
            chest.position.y = 2.9;
            chest.castShadow = true;
            joan.add(chest);
            
            const shoulderGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            leftShoulder.position.set(-0.95, 3.4, 0);
            leftShoulder.castShadow = true;
            joan.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, goldMaterial);
            rightShoulder.position.set(0.95, 3.4, 0);
            rightShoulder.castShadow = true;
            joan.add(rightShoulder);
            
            const legGeometry = new THREE.CylinderGeometry(0.26, 0.3, 1.6, 12);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.32, 0.5, 0);
            leftLeg.castShadow = true;
            joan.add(leftLeg);
            joan.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.32, 0.5, 0);
            rightLeg.castShadow = true;
            joan.add(rightLeg);
            joan.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.22, 0.25, 1.9, 12);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.95, 2.5, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            joan.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.95, 2.5, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            joan.add(rightArm);
            joan.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.55, 20, 20);
            const skinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD1A3,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 4.1;
            head.castShadow = true;
            joan.add(head);
            
            const hairGeometry = new THREE.SphereGeometry(0.6, 18, 14, 0, Math.PI * 2, 0, Math.PI * 0.6);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 4.3;
            hair.castShadow = true;
            joan.add(hair);
            
            const glowGeometry = new THREE.SphereGeometry(1.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2.5;
            joan.add(glow);
            joan.glow = glow;
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.8, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 150,
                specular: 0xFFFFFF
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.4;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            const guardGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.15);
            const guard = new THREE.Mesh(guardGeometry, goldMaterial);
            guard.castShadow = true;
            swordGroup.add(guard);
            
            swordGroup.position.set(1, 2.5, 0);
            swordGroup.rotation.z = -0.3;
            joan.add(swordGroup);
            joan.sword = swordGroup;
            
            const capeGeometry = new THREE.BoxGeometry(1.5, 2.2, 0.1);
            const capeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C,
                shininess: 15,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 2.2, -0.5);
            cape.castShadow = true;
            joan.add(cape);
            joan.cape = cape;
            
            const glowLight = new THREE.PointLight(0xFFFFFF, 0.5, 10);
            glowLight.position.y = 4;
            joan.add(glowLight);
            joan.glowLight = glowLight;
            
            joan.position.set(0, 0, 0);
            joan.health = gameState.maxHealth;
            joan.isPlayer = true;
            joan.walkCycle = 0;
            joan.direction = 0;
            
            return joan;
        }

        function createAlexander() {
            const alex = createJoan();
            
            // Modify colors for Alexander
            alex.children.forEach(function(child) {
                if (child.material && child.material.color) {
                    if (child.material.color.getHex() === 0x4169E1) {
                        child.material.color.setHex(0x8B4513); // Bronze armor
                    }
                    if (child.material.color.getHex() === 0xDC143C) {
                        child.material.color.setHex(0x800020); // Burgundy cape
                    }
                }
            });
            
            return alex;
        }

        function createAlly() {
            const ally = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.58, 0.78, 1.9, 16);
            const armorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B8B8B,
                shininess: 95,
                specular: 0xCCCCCC
            });
            const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
            torso.position.y = 2.4;
            torso.castShadow = true;
            ally.add(torso);
            
            const chestGeometry = new THREE.CylinderGeometry(0.68, 0.78, 1.1, 16);
            const plateArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xA9A9A9,
                shininess: 110,
                specular: 0xFFFFFF
            });
            const chest = new THREE.Mesh(chestGeometry, plateArmorMaterial);
            chest.position.y = 2.7;
            chest.castShadow = true;
            ally.add(chest);
            
            const crossVGeometry = new THREE.BoxGeometry(0.08, 0.6, 0.12);
            const crossMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDC143C
            });
            const crossV = new THREE.Mesh(crossVGeometry, crossMaterial);
            crossV.position.set(0, 2.7, 0.8);
            ally.add(crossV);
            
            const shoulderGeometry = new THREE.SphereGeometry(0.35, 14, 14);
            const leftShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            leftShoulder.position.set(-0.88, 3.25, 0);
            leftShoulder.castShadow = true;
            ally.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, plateArmorMaterial);
            rightShoulder.position.set(0.88, 3.25, 0);
            rightShoulder.castShadow = true;
            ally.add(rightShoulder);
            
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.28, 1.55, 14);
            const leftLeg = new THREE.Mesh(legGeometry, armorMaterial);
            leftLeg.position.set(-0.31, 0.48, 0);
            leftLeg.castShadow = true;
            ally.add(leftLeg);
            ally.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, armorMaterial);
            rightLeg.position.set(0.31, 0.48, 0);
            rightLeg.castShadow = true;
            ally.add(rightLeg);
            ally.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.21, 0.24, 1.75, 14);
            const leftArm = new THREE.Mesh(armGeometry, armorMaterial);
            leftArm.position.set(-0.88, 2.4, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            ally.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armorMaterial);
            rightArm.position.set(0.88, 2.4, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            ally.add(rightArm);
            ally.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.48, 16, 16);
            const skinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD1A3 });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 3.72;
            head.castShadow = true;
            ally.add(head);
            
            const helmetGeometry = new THREE.SphereGeometry(0.52, 16, 14, 0, Math.PI * 2, 0, Math.PI * 0.7);
            const helmetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB0B0B0,
                shininess: 105
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 3.88;
            helmet.castShadow = true;
            ally.add(helmet);
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.11, 2.4, 0.04);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xE8E8E8,
                shininess: 115
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 1.2;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            swordGroup.position.set(0.98, 2.4, 0);
            swordGroup.rotation.z = -0.3;
            ally.add(swordGroup);
            ally.sword = swordGroup;
            
            // Position will be set by calling function
            ally.targetEnemy = null;
            ally.attackCooldown = 0;
            ally.isAlly = true;
            ally.walkCycle = 0;
            ally.health = 80;
            
            return ally;
        }

        function positionAlliesInFormation(allies) {
            // Position 10 allies in formation around player
            const rows = 2;
            const soldiersPerRow = 5;
            const rowSpacing = 4;
            const colSpacing = 3.5;
            
            let allyIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < soldiersPerRow; col++) {
                    if (allyIndex < allies.length) {
                        const angle = (col / soldiersPerRow) * Math.PI * 2;
                        const distance = 8 + (row * rowSpacing);
                        
                        allies[allyIndex].position.set(
                            Math.cos(angle) * distance + (Math.random() - 0.5) * 2,
                            0,
                            Math.sin(angle) * distance + (Math.random() - 0.5) * 2
                        );
                        allyIndex++;
                    }
                }
            }
        }

        function createEnemy() {
            const enemy = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.55, 0.75, 1.8, 14);
            const darkArmorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a0000,
                shininess: 60
            });
            const torso = new THREE.Mesh(torsoGeometry, darkArmorMaterial);
            torso.position.y = 2.3;
            torso.castShadow = true;
            enemy.add(torso);
            
            const legGeometry = new THREE.CylinderGeometry(0.24, 0.27, 1.5, 12);
            const leftLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            leftLeg.position.set(-0.3, 0.45, 0);
            leftLeg.castShadow = true;
            enemy.add(leftLeg);
            enemy.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, darkArmorMaterial);
            rightLeg.position.set(0.3, 0.45, 0);
            rightLeg.castShadow = true;
            enemy.add(rightLeg);
            enemy.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.22, 1.7, 12);
            const leftArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            leftArm.position.set(-0.85, 2.3, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            enemy.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, darkArmorMaterial);
            rightArm.position.set(0.85, 2.3, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            enemy.add(rightArm);
            enemy.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.47, 16, 16);
            const darkSkinMaterial = new THREE.MeshPhongMaterial({ color: 0x505050 });
            const head = new THREE.Mesh(headGeometry, darkSkinMaterial);
            head.position.y = 3.65;
            head.castShadow = true;
            enemy.add(head);
            
            const swordGroup = new THREE.Group();
            const bladeGeometry = new THREE.BoxGeometry(0.12, 2.5, 0.04);
            const darkBladeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 90
            });
            const blade = new THREE.Mesh(bladeGeometry, darkBladeMaterial);
            blade.position.y = 1.25;
            blade.castShadow = true;
            swordGroup.add(blade);
            
            swordGroup.position.set(0.95, 2.3, 0);
            swordGroup.rotation.z = -0.3;
            enemy.add(swordGroup);
            enemy.sword = swordGroup;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 20;
            enemy.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            enemy.health = 30;
            enemy.speed = 0.08 + Math.random() * 0.04;
            enemy.attackCooldown = 0;
            enemy.isEnemy = true;
            enemy.walkCycle = 0;
            
            return enemy;
        }

        function createEnemyLeader() {
            const leader = createEnemy();
            leader.scale.set(1.3, 1.3, 1.3);
            
            const crownGeometry = new THREE.CylinderGeometry(0.45, 0.38, 0.5, 12);
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                emissive: 0x332200
            });
            const crown = new THREE.Mesh(crownGeometry, crownMaterial);
            crown.position.y = 3.2;
            crown.castShadow = true;
            leader.add(crown);
            
            const auraGeometry = new THREE.RingGeometry(2, 3, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.1;
            leader.add(aura);
            leader.aura = aura;
            
            leader.health = 200;
            leader.maxHealth = 200;
            leader.isLeader = true;
            
            return leader;
        }

        let player;
        
        function selectMode(mode) {
            console.log('selectMode called with mode:', mode);
            gameState.mode = mode;
            document.getElementById('modeSelection').classList.add('hidden');
            
            if (mode === 'story') {
                console.log('Starting story mode');
                showCutscene(0);
            } else if (mode === 'alexander') {
                console.log('Starting alexander mode');
                document.getElementById('characterName').textContent = '‚öîÔ∏è ALEXANDER THE GREAT ‚öîÔ∏è';
                showAlexanderIntro();
            } else if (mode === 'gun') {
                console.log('Starting Gun mode');
                // GUN MODE - Joan with dual pistols
                document.getElementById('characterName').textContent = 'üî´ JOAN OF ARC üî´';
                console.log('Creating Joan with guns');
                player = createJoanWithGuns();
                scene.add(player);
                
                console.log('Creating allies');
                // Create 10 allied soldiers in formation
                for (let i = 0; i < 10; i++) {
                    const ally = createAlly();
                    gameState.allies.push(ally);
                    scene.add(ally);
                }
                positionAlliesInFormation(gameState.allies);
                
                console.log('Starting music');
                // Start background music
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                playBackgroundMusic();
                
                console.log('Starting game');
                gameState.gameStarted = true;
                gameState.readyToPlay = true;
                if (!gameState.animateStarted) {
                    gameState.animateStarted = true;
                    animate();
                }
            }
            console.log('selectMode completed successfully');
        }

        function showAlexanderIntro() {
            showAlexanderCutscene(0);
        }

        function showCutscene(chapterIndex) {
            const chapter = storyChapters[chapterIndex];
            document.getElementById('cutsceneTitle').textContent = chapter.title;
            document.getElementById('cutsceneText').textContent = chapter.text;
            document.getElementById('cutsceneScreen').classList.remove('hidden');
        }

        function endCutscene() {
            document.getElementById('cutsceneScreen').classList.add('hidden');
            
            // Check if we're coming from historical quotes/notes completion
            if (gameState.nextAction === 'victory') {
                gameState.nextAction = null;
                showVictory();
                return;
            } else if (gameState.nextAction === 'nextChapter') {
                gameState.nextAction = null;
                gameState.currentChapter = gameState.pendingChapter;
                gameState.pendingChapter = null;
                showCutscene(gameState.currentChapter);
                return;
            } else if (gameState.nextAction === 'nextAlexanderChapter') {
                gameState.nextAction = null;
                gameState.currentChapter = gameState.pendingChapter;
                gameState.pendingChapter = null;
                showAlexanderCutscene(gameState.currentChapter);
                return;
            }
            
            // Start background music
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
            
            if (gameState.mode === 'story') {
                showDialogue(gameState.currentChapter);
            } else if (gameState.mode === 'alexander') {
                showAlexanderDialogue(gameState.currentChapter);
            }
        }
        
        function showAlexanderCutscene(chapterIndex) {
            const chapter = alexanderChapters[chapterIndex];
            
            document.getElementById('cutsceneTitle').textContent = chapter.title;
            document.getElementById('cutsceneText').textContent = chapter.text + '\n\nLocation: ' + chapter.location;
            document.getElementById('cutsceneScreen').classList.remove('hidden');
        }
        
        function showAlexanderDialogue(chapterIndex) {
            const chapter = alexanderChapters[chapterIndex];
            const dialogue = chapter.dialogue;
            
            document.getElementById('speakerName').textContent = dialogue.speaker;
            document.getElementById('dialogueText').textContent = dialogue.text;
            
            const optionsDiv = document.getElementById('dialogueOptions');
            optionsDiv.innerHTML = '';
            
            dialogue.options.forEach(function(option) {
                const button = document.createElement('div');
                button.className = 'dialogue-option';
                button.textContent = option.text;
                button.onclick = function() {
                    if (option.response === 'quest') {
                        startAlexanderQuest(chapterIndex);
                    }
                };
                optionsDiv.appendChild(button);
            });
            
            document.getElementById('dialogueScreen').classList.remove('hidden');
        }
        
        function startAlexanderQuest(chapterIndex) {
            document.getElementById('dialogueScreen').classList.add('hidden');
            
            const chapter = alexanderChapters[chapterIndex];
            
            if (!player) {
                player = createAlexander();
                scene.add(player);
                
                // Create 10 allied soldiers in formation
                for (let i = 0; i < 10; i++) {
                    const ally = createAlly();
                    gameState.allies.push(ally);
                    scene.add(ally);
                }
                positionAlliesInFormation(gameState.allies);
            }
            
            gameState.questActive = true;
            gameState.questComplete = false;
            gameState.kills = 0;
            gameState.leadersDefeated = 0;
            gameState.prayers = 0;
            
            gameState.totalLeaders = chapter.objective.leaders;
            document.getElementById('totalLeaders').textContent = chapter.objective.leaders;
            
            document.getElementById('questLog').classList.remove('hidden');
            document.getElementById('questObjective').textContent = chapter.quest;
            
            // Start background music
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
            
            // Now ready to play - start game loop
            gameState.gameStarted = true;
            gameState.readyToPlay = true;
            if (!gameState.animateStarted) {
                gameState.animateStarted = true;
                animate();
            }
        }

        function showDialogue(chapterIndex) {
            const chapter = storyChapters[chapterIndex];
            const dialogue = chapter.dialogue;
            
            // Setup stage environment based on chapter
            setupStageForChapter(chapterIndex);
            
            document.getElementById('speakerName').textContent = dialogue.speaker;
            document.getElementById('dialogueText').textContent = dialogue.text;
            
            const optionsDiv = document.getElementById('dialogueOptions');
            optionsDiv.innerHTML = '';
            
            dialogue.options.forEach(function(option) {
                const button = document.createElement('div');
                button.className = 'dialogue-option';
                button.textContent = option.text;
                button.onclick = function() {
                    if (option.response === 'quest') {
                        startQuest(chapterIndex);
                    }
                };
                optionsDiv.appendChild(button);
            });
            
            document.getElementById('dialogueScreen').classList.remove('hidden');
        }
        
        function setupStageForChapter(chapterIndex) {
            // Clear any existing stage objects
            if (typeof stageObjects !== 'undefined') {
                stageObjects.forEach(obj => {
                    if (obj && scene) scene.remove(obj);
                });
                stageObjects = [];
            }
            
            const chapter = storyChapters[chapterIndex];
            if (!chapter) return;
            
            // Set environment and create detailed stages based on chapter
            if (chapterIndex === 0) {
                // Chapter 1: Small Catholic Church - Childhood prayers
                createSmallCatholicChurch(false);
            } else if (chapterIndex === 1) {
                // Chapter 2: Small Catholic Church with altar - Receiving voices
                createSmallCatholicChurch(true);
            } else if (chapterIndex === 2) {
                // Village - bright daylight
                scene.background = new THREE.Color(0x87CEEB);
                if (scene.fog) scene.fog.color.setHex(0xB8D4E8);
            } else if (chapterIndex === 4) {
                // Chapter 5: Small Catholic Church with altar - Poitiers examination
                createSmallCatholicChurch(true);
            } else if (chapterIndex === 7) {
                // Chapter 8: Mass in small Catholic Church with priest
                createSmallCatholicChurchWithMass();
            } else {
                // Battlefield/Road - green fields
                scene.background = new THREE.Color(0xA8D8A8);
                if (scene.fog) scene.fog.color.setHex(0xB8E6B8);
            }
        }
        
        function createSmallCatholicChurch(showAltar) {
            // Small medieval village church interior
            scene.background = new THREE.Color(0xD4C8B8); // Warm stone color
            if (scene.fog) {
                scene.fog.color.setHex(0xE8DCC8);
                scene.fog.near = 20;
                scene.fog.far = 80;
            }
            
            // Golden marble floor with detailed texture
            const floorGeometry = new THREE.PlaneGeometry(40, 50);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5DEB3, // Golden wheat marble color
                shininess: 80,
                specular: 0xFFFFDD,
                reflectivity: 0.3
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            stageObjects.push(floor);
            scene.add(floor);
            
            // Marble veining pattern (darker gold streaks)
            for (let i = 0; i < 8; i++) {
                const veinGeometry = new THREE.PlaneGeometry(2 + Math.random() * 3, 45);
                const veinMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xD4AF37, // Darker gold veins
                    transparent: true,
                    opacity: 0.4,
                    shininess: 90
                });
                const vein = new THREE.Mesh(veinGeometry, veinMaterial);
                vein.rotation.x = -Math.PI / 2;
                vein.rotation.z = Math.random() * Math.PI / 4;
                vein.position.set((Math.random() - 0.5) * 35, 0.01, (Math.random() - 0.5) * 45);
                stageObjects.push(vein);
                scene.add(vein);
            }
            
            // Church walls
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xB8A89A });
            
            // Left wall
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 50), wallMaterial);
            leftWall.position.set(-20, 6, 0);
            leftWall.castShadow = true;
            stageObjects.push(leftWall);
            scene.add(leftWall);
            
            // Right wall
            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 50), wallMaterial);
            rightWall.position.set(20, 6, 0);
            rightWall.castShadow = true;
            stageObjects.push(rightWall);
            scene.add(rightWall);
            
            // Back wall with arch
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(40, 12, 1), wallMaterial);
            backWall.position.set(0, 6, -25);
            backWall.castShadow = true;
            stageObjects.push(backWall);
            scene.add(backWall);
            
            if (showAltar) {
                // Main altar at front of church
                const altarBase = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 1.5, 5),
                    new THREE.MeshPhongMaterial({ color: 0xA0826D })
                );
                altarBase.position.set(0, 0.75, -20);
                altarBase.castShadow = true;
                stageObjects.push(altarBase);
                scene.add(altarBase);
                
                // Altar top with cloth
                const altarCloth = new THREE.Mesh(
                    new THREE.BoxGeometry(10.5, 0.2, 5.5),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xF8F8F8, // White altar cloth
                        shininess: 10
                    })
                );
                altarCloth.position.set(0, 1.6, -20);
                stageObjects.push(altarCloth);
                scene.add(altarCloth);
                
                // Golden cross on altar
                const crossVertical = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 3, 0.4),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xFFD700,
                        emissive: 0x886600,
                        shininess: 100
                    })
                );
                crossVertical.position.set(0, 3.2, -20);
                stageObjects.push(crossVertical);
                scene.add(crossVertical);
                
                const crossHorizontal = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.4, 0.4),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xFFD700,
                        emissive: 0x886600,
                        shininess: 100
                    })
                );
                crossHorizontal.position.set(0, 3.5, -20);
                stageObjects.push(crossHorizontal);
                scene.add(crossHorizontal);
                
                // Candles on altar
                for (let i = -1; i <= 1; i += 2) {
                    // Candlestick
                    const candlestick = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8),
                        new THREE.MeshPhongMaterial({ color: 0xC9A961 })
                    );
                    candlestick.position.set(i * 4, 2.1, -20);
                    stageObjects.push(candlestick);
                    scene.add(candlestick);
                    
                    // Candle
                    const candle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.12, 0.6, 8),
                        new THREE.MeshPhongMaterial({ color: 0xFFF8DC })
                    );
                    candle.position.set(i * 4, 2.8, -20);
                    stageObjects.push(candle);
                    scene.add(candle);
                    
                    // Candle flame (glowing sphere)
                    const flame = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshBasicMaterial({ 
                            color: 0xFFAA44,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    flame.position.set(i * 4, 3.2, -20);
                    stageObjects.push(flame);
                    scene.add(flame);
                    
                    // Point light for flame
                    const candleLight = new THREE.PointLight(0xFFAA44, 0.8, 15);
                    candleLight.position.set(i * 4, 3.2, -20);
                    stageObjects.push(candleLight);
                    scene.add(candleLight);
                }
            }
            
            // Wooden pews (6 rows, 2 per row)
            const pewMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            for (let row = 0; row < 6; row++) {
                // Left pew
                const pewLeft = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 1), pewMaterial);
                pewLeft.position.set(-10, 0.6, -8 + row * 3);
                pewLeft.castShadow = true;
                stageObjects.push(pewLeft);
                scene.add(pewLeft);
                
                // Pew back
                const pewBackLeft = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.2), pewMaterial);
                pewBackLeft.position.set(-10, 1.6, -8.5 + row * 3);
                stageObjects.push(pewBackLeft);
                scene.add(pewBackLeft);
                
                // Right pew
                const pewRight = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 1), pewMaterial);
                pewRight.position.set(10, 0.6, -8 + row * 3);
                pewRight.castShadow = true;
                stageObjects.push(pewRight);
                scene.add(pewRight);
                
                // Pew back
                const pewBackRight = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.2), pewMaterial);
                pewBackRight.position.set(10, 1.6, -8.5 + row * 3);
                stageObjects.push(pewBackRight);
                scene.add(pewBackRight);
            }
            
            // Stained glass window effect (colored light from back)
            const stainedGlassLight = new THREE.PointLight(0x6495ED, 1.2, 35);
            stainedGlassLight.position.set(0, 8, -24);
            stageObjects.push(stainedGlassLight);
            scene.add(stainedGlassLight);
            
            // Warm ambient church lighting
            const churchAmbient = new THREE.AmbientLight(0xFFE4B5, 0.6);
            stageObjects.push(churchAmbient);
            scene.add(churchAmbient);
        }
        
        function createSmallCatholicChurchWithMass() {
            // Create base church with altar
            createSmallCatholicChurch(true);
            
            // Add priest figure at altar for Mass
            const priestGroup = new THREE.Group();
            
            // Priest body (white alb with green chasuble)
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.6, 2, 12),
                new THREE.MeshPhongMaterial({ color: 0x2D5016 }) // Green liturgical vestment
            );
            body.position.y = 2.5;
            priestGroup.add(body);
            
            // White alb showing at bottom
            const alb = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.65, 0.5, 12),
                new THREE.MeshPhongMaterial({ color: 0xF8F8F8 })
            );
            alb.position.y = 1.25;
            priestGroup.add(alb);
            
            // Priest head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 12, 12),
                new THREE.MeshPhongMaterial({ color: 0xFFD1A3 })
            );
            head.position.y = 3.8;
            priestGroup.add(head);
            
            // Priest arms (raised in blessing/consecration)
            const armLeft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8),
                new THREE.MeshPhongMaterial({ color: 0xF8F8F8 })
            );
            armLeft.position.set(-0.7, 2.8, 0);
            armLeft.rotation.z = Math.PI / 4;
            priestGroup.add(armLeft);
            
            const armRight = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8),
                new THREE.MeshPhongMaterial({ color: 0xF8F8F8 })
            );
            armRight.position.set(0.7, 2.8, 0);
            armRight.rotation.z = -Math.PI / 4;
            priestGroup.add(armRight);
            
            // Position priest behind altar
            priestGroup.position.set(0, 0, -22);
            priestGroup.castShadow = true;
            stageObjects.push(priestGroup);
            scene.add(priestGroup);
            
            // Chalice on altar
            const chaliceBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.25, 0.2, 12),
                new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100 })
            );
            chaliceBase.position.set(-2, 1.8, -20);
            stageObjects.push(chaliceBase);
            scene.add(chaliceBase);
            
            const chaliceCup = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25, 0.15, 0.4, 12),
                new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100 })
            );
            chaliceCup.position.set(-2, 2.1, -20);
            stageObjects.push(chaliceCup);
            scene.add(chaliceCup);
            
            // Paten (plate) with Host
            const paten = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16),
                new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100 })
            );
            paten.position.set(2, 1.8, -20);
            stageObjects.push(paten);
            scene.add(paten);
            
            // Host (consecrated bread)
            const host = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 0.02, 16),
                new THREE.MeshPhongMaterial({ color: 0xFFFAF0, emissive: 0xFFFFAA, emissiveIntensity: 0.3 })
            );
            host.position.set(2, 1.88, -20);
            stageObjects.push(host);
            scene.add(host);
            
            // Holy light from above (representing divine presence)
            const divineLight = new THREE.SpotLight(0xFFFFE0, 2, 30, Math.PI / 6);
            divineLight.position.set(0, 12, -20);
            divineLight.target.position.set(0, 1.8, -20);
            stageObjects.push(divineLight);
            scene.add(divineLight);
            scene.add(divineLight.target);
        }


        function startQuest(chapterIndex) {
            document.getElementById('dialogueScreen').classList.add('hidden');
            
            const chapter = storyChapters[chapterIndex];
            
            if (!player) {
                player = createJoan();
                scene.add(player);
                
                // Only create allies for combat chapters
                if (chapter.objective.type === 'kills' || chapter.objective.type === 'leaders' || 
                    (chapter.objective.type === 'both' && chapter.objective.kills)) {
                    // Create 10 allied soldiers in formation
                    for (let i = 0; i < 10; i++) {
                        const ally = createAlly();
                        gameState.allies.push(ally);
                        scene.add(ally);
                    }
                    positionAlliesInFormation(gameState.allies);
                }
            }
            
            gameState.questActive = true;
            gameState.questComplete = false;
            gameState.kills = 0;
            gameState.leadersDefeated = 0;
            gameState.prayers = 0;
            
            if (chapter.objective.type === 'leaders') {
                gameState.totalLeaders = chapter.objective.count;
                document.getElementById('totalLeaders').textContent = chapter.objective.count;
            } else if (chapter.objective.type === 'both' && chapter.objective.leaders) {
                gameState.totalLeaders = chapter.objective.leaders;
                document.getElementById('totalLeaders').textContent = chapter.objective.leaders;
            }
            
            document.getElementById('questLog').classList.remove('hidden');
            document.getElementById('questObjective').textContent = chapter.quest;
            
            // Start background music
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
            
            // Now ready to play - start game loop
            gameState.gameStarted = true;
            gameState.readyToPlay = true;
            if (!gameState.animateStarted) {
                gameState.animateStarted = true;
                animate();
            }
        }

        function checkQuestComplete() {
            if (!gameState.questActive || gameState.questComplete) return;
            
            let complete = false;
            
            if (gameState.mode === 'alexander') {
                // Alexander mode - check current chapter objectives
                const alexChapter = alexanderChapters[gameState.currentChapter];
                if (alexChapter && alexChapter.objective.type === 'both') {
                    if (gameState.kills >= alexChapter.objective.kills && gameState.leadersDefeated >= alexChapter.objective.leaders) {
                        complete = true;
                    }
                }
            } else if (gameState.mode === 'gun') {
                // Gun Mode - endless mode, no completion
                return;
            } else {
                // Story mode - now with prayer support
                const chapter = storyChapters[gameState.currentChapter];
                if (chapter.objective.type === 'kills') {
                    if (gameState.kills >= chapter.objective.count) {
                        complete = true;
                    }
                } else if (chapter.objective.type === 'leaders') {
                    if (gameState.leadersDefeated >= chapter.objective.count) {
                        complete = true;
                    }
                } else if (chapter.objective.type === 'prayers') {
                    if (gameState.prayers >= chapter.objective.count) {
                        complete = true;
                    }
                } else if (chapter.objective.type === 'both') {
                    if (chapter.objective.kills && chapter.objective.leaders) {
                        if (gameState.kills >= chapter.objective.kills && gameState.leadersDefeated >= chapter.objective.leaders) {
                            complete = true;
                        }
                    } else if (chapter.objective.kills && chapter.objective.prayers) {
                        if (gameState.kills >= chapter.objective.kills && gameState.prayers >= chapter.objective.prayers) {
                            complete = true;
                        }
                    }
                }
            }
            
            if (complete) {
                gameState.questComplete = true;
                gameState.questActive = false;
                
                if (gameState.mode === 'alexander') {
                    const alexChapter = alexanderChapters[gameState.currentChapter];
                    // Show historical note if available
                    if (alexChapter.historicalNote) {
                        showAlexanderHistoricalNote(gameState.currentChapter);
                    }
                    
                    // Progress to next chapter or victory
                    if (alexChapter.nextChapter === -1) {
                        // Final chapter - show victory
                        gameState.nextAction = 'victory';
                    } else {
                        // Progress to next chapter
                        gameState.nextAction = 'nextAlexanderChapter';
                        gameState.pendingChapter = alexChapter.nextChapter;
                    }
                } else {
                    const chapter = storyChapters[gameState.currentChapter];
                    // Show historical quotes after completing chapter
                    // Store next action for Continue button
                    if (chapter.nextChapter === -1) {
                        gameState.nextAction = 'victory';
                    } else {
                        gameState.nextAction = 'nextChapter';
                        gameState.pendingChapter = chapter.nextChapter;
                    }
                    showHistoricalQuotes(gameState.currentChapter);
                }
            }
        }
        
        function showHistoricalQuotes(chapterIndex) {
            const chapter = storyChapters[chapterIndex];
            let quoteText = '';
            
            if (chapter.historicalQuote) {
                quoteText += 'JOAN\'S WORDS:\n\n' + chapter.historicalQuote + '\n\n';
            }
            if (chapter.scholarlyQuote) {
                quoteText += 'HISTORICAL ACCOUNT:\n\n' + chapter.scholarlyQuote;
            }
            
            if (quoteText) {
                document.getElementById('cutsceneTitle').textContent = 'Chapter ' + (chapterIndex + 1) + ' Complete';
                document.getElementById('cutsceneText').textContent = quoteText;
                document.getElementById('cutsceneScreen').classList.remove('hidden');
                
                // No auto-advance - user must click Continue button to proceed
            }
        }
        
        function showAlexanderHistoricalNote(chapterIndex) {
            const chapter = alexanderChapters[chapterIndex];
            
            if (chapter.historicalNote) {
                document.getElementById('cutsceneTitle').textContent = chapter.title + ' - Complete';
                document.getElementById('cutsceneText').textContent = 'HISTORICAL NOTE:\n\n' + chapter.historicalNote;
                document.getElementById('cutsceneScreen').classList.remove('hidden');
                
                // No auto-advance - user must click Continue button to proceed
            } else {
                // No historical note, proceed immediately
                if (gameState.nextAction === 'victory') {
                    gameState.nextAction = null;
                    showVictory();
                } else if (gameState.nextAction === 'nextAlexanderChapter') {
                    gameState.nextAction = null;
                    gameState.currentChapter = gameState.pendingChapter;
                    gameState.pendingChapter = null;
                    showAlexanderCutscene(gameState.currentChapter);
                }
            }
        }

        function showVictory() {
            document.getElementById('victoryMessage').textContent = 
                gameState.mode === 'alexander' ? 
                'You have conquered the Persian Empire! History remembers Alexander the Great!' :
                'France is saved! Joan of Arc has fulfilled her divine mission!';
            document.getElementById('victoryScreen').classList.remove('hidden');
        }

        // Joystick Controls
        const joystickBase = document.getElementById('joystickBase');
        const joystickStick = document.getElementById('joystickStick');
        
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        
        joystickBase.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            joystickActive = true;
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
        }, { passive: false });
        
        joystickBase.addEventListener('touchmove', function(e) {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - joystickStartX;
            const deltaY = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 38;
            const clampedDistance = Math.min(distance, maxDistance);
            
            const angle = Math.atan2(deltaY, deltaX);
            const clampedX = Math.cos(angle) * clampedDistance;
            const clampedY = Math.sin(angle) * clampedDistance;
            
            joystickStick.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;
            
            mobileControls.moveVector.x = clampedX / maxDistance;
            mobileControls.moveVector.z = clampedY / maxDistance;
        }, { passive: false });
        
        joystickBase.addEventListener('touchend', function(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            mobileControls.moveVector.x = 0;
            mobileControls.moveVector.z = 0;
        }, { passive: false });

        document.getElementById('attackButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (!gameState.isAttacking && gameState.gameStarted) {
                playerAttack();
            }
        }, { passive: false });
        
        document.getElementById('specialButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.special >= 50 && gameState.gameStarted) {
                specialAttack();
            }
        }, { passive: false });
        
        document.getElementById('prayButton').addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.gameStarted) {
                prayForLeader();
            }
        }, { passive: false });
        
        function prayForLeader() {
            // Heal player by 15 HP
            gameState.health = Math.min(gameState.maxHealth, gameState.health + 15);
            
            // Count prayer for church chapters
            const currentChapter = storyChapters[gameState.currentChapter];
            if (currentChapter && currentChapter.gameplay === 'church') {
                gameState.prayers++;
                updateUI();
                checkQuestComplete();
            }
            
            updateUI();
            
            // Play healing sound
            playHealSound();
            
            // Create healing effect
            createHealingEffect(player.position);
            
            // Flash effect
            const flashDiv = document.createElement('div');
            flashDiv.style.position = 'fixed';
            flashDiv.style.top = '0';
            flashDiv.style.left = '0';
            flashDiv.style.width = '100%';
            flashDiv.style.height = '100%';
            flashDiv.style.background = 'rgba(255, 215, 0, 0.3)';
            flashDiv.style.pointerEvents = 'none';
            flashDiv.style.zIndex = '50';
            document.body.appendChild(flashDiv);
            
            setTimeout(function() {
                document.body.removeChild(flashDiv);
            }, 500);
            
            // Find and mark nearest leader (if any)
            if (gameState.leaders.length > 0) {
                let nearestLeader = null;
                let nearestDistance = Infinity;
                
                gameState.leaders.forEach(function(leader) {
                    const distance = player.position.distanceTo(leader.position);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestLeader = leader;
                    }
                });
                
                gameState.prayTarget = nearestLeader;
            }
        }

        function playerAttack() {
            gameState.isAttacking = true;
            
            // GUN MODE - Fire bullets from dual pistols
            if (player.hasGuns) {
                // Safety check for guns
                if (!player.leftGun || !player.rightGun) {
                    gameState.isAttacking = false;
                    return;
                }
                
                // Play gunshot sound
                playGunSound();
                
                // Fire from left gun - get world position
                const leftGunWorldPos = new THREE.Vector3();
                player.leftGun.getWorldPosition(leftGunWorldPos);
                fireBullet(leftGunWorldPos, player.rotation.y);
                
                // Slight delay for right gun
                setTimeout(function() {
                    if (!player || !player.rightGun) return;
                    playGunSound();
                    const rightGunWorldPos = new THREE.Vector3();
                    player.rightGun.getWorldPosition(rightGunWorldPos);
                    fireBullet(rightGunWorldPos, player.rotation.y);
                }, 100);
                
                // Gun recoil animation
                const leftGunOriginal = player.leftGun.rotation.z;
                const rightGunOriginal = player.rightGun.rotation.z;
                
                player.leftGun.rotation.z = leftGunOriginal - 0.3;
                player.rightGun.rotation.z = rightGunOriginal + 0.3;
                
                setTimeout(function() {
                    if (player && player.leftGun && player.rightGun) {
                        player.leftGun.rotation.z = leftGunOriginal;
                        player.rightGun.rotation.z = rightGunOriginal;
                    }
                    gameState.isAttacking = false;
                }, 200);
                
                return;
            }
            
            // SWORD MODE (story/alexander)
            if (!player.sword) {
                gameState.isAttacking = false;
                return;
            }
            
            // Play sword slash sound
            playSwordSlashSound();
            
            const sword = player.sword;
            const originalRotation = sword.rotation.z;
            
            let swingProgress = 0;
            function animateSwing() {
                swingProgress += 0.15;
                if (swingProgress < 1) {
                    sword.rotation.z = originalRotation - Math.sin(swingProgress * Math.PI) * Math.PI / 2;
                    requestAnimationFrame(animateSwing);
                } else {
                    sword.rotation.z = originalRotation;
                    gameState.isAttacking = false;
                }
            }
            animateSwing();
            
            let hitSomething = false;
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 5) {
                    const damage = enemy.isLeader ? 15 : 25;
                    enemy.health -= damage;
                    hitSomething = true;
                    
                    // Play hit sound
                    playHitSound();
                    
                    // Create slash effect
                    createSlashEffect(enemy.position, new THREE.Vector3());
                    
                    // Knockback
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(3.5));
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
            
            if (hitSomething) {
                updateCombo();
            }
        }
        
        // Bullet projectile system for gun mode
        function fireBullet(startPos, direction) {
            const bulletGeometry = new THREE.SphereGeometry(0.3, 12, 12); // Much bigger bullets
            const bulletMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 1.0
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(startPos);
            bullet.position.y = 2.5;
            
            const speed = 1.5;
            const velocity = {
                x: Math.sin(direction) * speed,
                z: Math.cos(direction) * speed
            };
            
            bullet.velocity = velocity;
            bullet.lifetime = 0;
            bullet.hasHit = false;
            scene.add(bullet);
            
            function updateBullet() {
                // Safety checks to prevent errors
                if (!bullet || bullet.hasHit || !bullet.position) {
                    if (bullet && scene) {
                        try {
                            scene.remove(bullet);
                        } catch (e) {
                            // Silently fail if already removed
                        }
                    }
                    return;
                }
                
                bullet.lifetime++;
                
                // Safely update position
                try {
                    bullet.position.x += bullet.velocity.x;
                    bullet.position.z += bullet.velocity.z;
                } catch (e) {
                    scene.remove(bullet);
                    return;
                }
                
                // Check collision with all enemies
                if (gameState.enemies && gameState.enemies.length > 0) {
                    for (let i = 0; i < gameState.enemies.length; i++) {
                        const enemy = gameState.enemies[i];
                        if (!enemy || !enemy.position) continue;
                        
                        try {
                            const distance = bullet.position.distanceTo(enemy.position);
                            
                            if (distance < 3) {
                                bullet.hasHit = true;
                                
                                const damage = enemy.isLeader ? 25 : 35;
                                enemy.health -= damage;
                                
                                playHitSound();
                                createSlashEffect(enemy.position, new THREE.Vector3());
                                
                                const knockbackDir = new THREE.Vector3()
                                    .subVectors(enemy.position, player.position)
                                    .normalize();
                                enemy.position.add(knockbackDir.multiplyScalar(2.5));
                                
                                if (enemy.health <= 0) {
                                    killEnemy(enemy);
                                }
                                
                                updateCombo();
                                scene.remove(bullet);
                                return;
                            }
                        } catch (e) {
                            // Skip this enemy if error
                            continue;
                        }
                    }
                }
                
                if (bullet.lifetime > 80) {
                    try {
                        scene.remove(bullet);
                    } catch (e) {
                        // Already removed
                    }
                } else {
                    requestAnimationFrame(updateBullet);
                }
            }
            updateBullet();
        }

        function specialAttack() {
            gameState.special -= 50;
            updateUI();
            
            // Play divine sound
            playDivineSound();
            
            // Create divine explosion effect at player position
            createDivineExplosion(player.position);
            
            gameState.enemies.forEach(function(enemy) {
                const distance = player.position.distanceTo(enemy.position);
                if (distance < 15) {
                    enemy.health -= 50;
                    
                    // Knockback enemies away from player
                    const direction = new THREE.Vector3()
                        .subVectors(enemy.position, player.position)
                        .normalize();
                    enemy.position.add(direction.multiplyScalar(6));
                    
                    // Create impact effect on each enemy
                    createSlashEffect(enemy.position, direction);
                    
                    if (enemy.health <= 0) {
                        killEnemy(enemy);
                    }
                }
            });
        }

        function killEnemy(enemy) {
            scene.remove(enemy);
            gameState.enemies = gameState.enemies.filter(function(e) { return e !== enemy; });
            
            if (enemy.isLeader) {
                gameState.leaders = gameState.leaders.filter(function(l) { return l !== enemy; });
                gameState.leadersDefeated++;
            }
            
            gameState.kills++;
            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 10);
            updateUI();
            checkQuestComplete();
        }

        function updateCombo() {
            gameState.combo++;
            gameState.comboHits++;
            
            if (gameState.comboTimer) {
                clearTimeout(gameState.comboTimer);
            }
            
            const comboElement = document.getElementById('comboCounter');
            comboElement.textContent = gameState.combo + ' HIT COMBO!';
            comboElement.classList.add('show');
            
            gameState.comboTimer = setTimeout(function() {
                gameState.combo = 0;
                comboElement.classList.remove('show');
            }, 2000);
        }

        function updateUI() {
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('specialBar').style.width = (gameState.special / gameState.maxSpecial * 100) + '%';
            document.getElementById('killCount').textContent = gameState.kills;
            document.getElementById('leaderCount').textContent = gameState.leadersDefeated;
            document.getElementById('comboHits').textContent = gameState.comboHits;
        }

        // Visual Effects
        function createSlashEffect(position, direction) {
            const particles = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                
                const angle = (i / 8) * Math.PI * 2;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * 0.5;
                particle.position.z += Math.sin(angle) * 0.5;
                particle.position.y += 2;
                
                particle.velocity = {
                    x: Math.cos(angle) * 0.2,
                    y: 0.1,
                    z: Math.sin(angle) * 0.2
                };
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            let life = 0;
            const animateParticles = function() {
                life++;
                if (life > 15) {
                    scene.remove(particles);
                    return;
                }
                
                particles.children.forEach(function(particle) {
                    particle.position.x += particle.velocity.x;
                    particle.position.y += particle.velocity.y;
                    particle.position.z += particle.velocity.z;
                    particle.velocity.y -= 0.02;
                    particle.material.opacity -= 0.05;
                });
                
                requestAnimationFrame(animateParticles);
            };
            animateParticles();
        }
        
        function createDivineExplosion(position) {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8
            });
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(position);
            explosion.position.y = 2;
            scene.add(explosion);
            
            let scale = 1;
            const animateExplosion = function() {
                scale += 0.8;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.08;
                
                if (explosion.material.opacity <= 0) {
                    scene.remove(explosion);
                } else {
                    requestAnimationFrame(animateExplosion);
                }
            };
            animateExplosion();
        }
        
        function createHealingEffect(position) {
            const particles = new THREE.Group();
            
            for (let i = 0; i < 12; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geometry, material);
                
                const angle = (i / 12) * Math.PI * 2;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * 1.5;
                particle.position.z += Math.sin(angle) * 1.5;
                particle.position.y += 0.5;
                
                particle.targetY = position.y + 3;
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            let life = 0;
            const animateHealing = function() {
                life++;
                if (life > 30) {
                    scene.remove(particles);
                    return;
                }
                
                particles.children.forEach(function(particle) {
                    particle.position.y += 0.1;
                    particle.material.opacity -= 0.03;
                });
                
                requestAnimationFrame(animateHealing);
            };
            animateHealing();
        }

        function checkCollision(character, newX, newZ) {
            const collisionRadius = 2.5; // Minimum distance between characters
            const testPosition = new THREE.Vector3(newX, character.position.y, newZ);
            
            // Check collision with player
            if (character !== player) {
                const distToPlayer = testPosition.distanceTo(player.position);
                if (distToPlayer < collisionRadius) {
                    return true;
                }
            }
            
            // Check collision with allies
            for (let i = 0; i < gameState.allies.length; i++) {
                const ally = gameState.allies[i];
                if (character !== ally) {
                    const distToAlly = testPosition.distanceTo(ally.position);
                    if (distToAlly < collisionRadius) {
                        return true;
                    }
                }
            }
            
            // Check collision with enemies
            for (let i = 0; i < gameState.enemies.length; i++) {
                const enemy = gameState.enemies[i];
                if (character !== enemy) {
                    const distToEnemy = testPosition.distanceTo(enemy.position);
                    if (distToEnemy < collisionRadius) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function applyCollisionAvoidance(character, direction, speed) {
            const newX = character.position.x + direction.x * speed;
            const newZ = character.position.z + direction.z * speed;
            
            // Check if new position would collide
            if (!checkCollision(character, newX, newZ)) {
                // No collision, move normally
                character.position.x = newX;
                character.position.z = newZ;
                return true;
            } else {
                // Try moving just in X direction
                if (!checkCollision(character, newX, character.position.z)) {
                    character.position.x = newX;
                    return true;
                }
                
                // Try moving just in Z direction
                if (!checkCollision(character, character.position.x, newZ)) {
                    character.position.z = newZ;
                    return true;
                }
                
                // Can't move, blocked
                return false;
            }
        }

        function updateEnemy(enemy) {
            const playerDistance = enemy.position.distanceTo(player.position);
            
            if (playerDistance > 3) {
                const direction = new THREE.Vector3()
                    .subVectors(player.position, enemy.position)
                    .normalize();
                
                // Apply collision-aware movement
                const moved = applyCollisionAvoidance(enemy, direction, enemy.speed);
                
                if (moved) {
                    enemy.lookAt(player.position);
                    
                    enemy.walkCycle += 0.14;
                    const legSwing = Math.sin(enemy.walkCycle) * 0.5;
                    enemy.leftLeg.rotation.x = legSwing;
                    enemy.rightLeg.rotation.x = -legSwing;
                }
            } else {
                enemy.lookAt(player.position);
                
                if (enemy.attackCooldown <= 0) {
                    enemy.attackCooldown = 90;
                    gameState.health -= 5;
                    updateUI();
                    
                    if (gameState.health <= 0) {
                        alert('Defeated! You killed ' + gameState.kills + ' enemies.');
                        location.reload();
                    }
                }
            }
            
            if (enemy.attackCooldown > 0) {
                enemy.attackCooldown--;
            }
        }

        function updateAlly(ally) {
            if (!ally.targetEnemy || ally.targetEnemy.health <= 0) {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                gameState.enemies.forEach(function(enemy) {
                    const distance = ally.position.distanceTo(enemy.position);
                    if (distance < nearestDistance && distance < 35) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                ally.targetEnemy = nearestEnemy;
            }
            
            if (ally.targetEnemy) {
                const direction = new THREE.Vector3()
                    .subVectors(ally.targetEnemy.position, ally.position);
                const distance = direction.length();
                
                if (distance > 3.5) {
                    direction.normalize();
                    
                    // Apply collision-aware movement
                    const moved = applyCollisionAvoidance(ally, direction, 0.11);
                    
                    if (moved) {
                        ally.lookAt(ally.targetEnemy.position);
                        
                        ally.walkCycle += 0.16;
                        const legSwing = Math.sin(ally.walkCycle) * 0.52;
                        ally.leftLeg.rotation.x = legSwing;
                        ally.rightLeg.rotation.x = -legSwing;
                        ally.rightArm.rotation.x = Math.sin(ally.walkCycle) * 0.33;
                    }
                } else {
                    ally.lookAt(ally.targetEnemy.position);
                    
                    if (ally.attackCooldown <= 0) {
                        ally.attackCooldown = 65;
                        ally.targetEnemy.health -= 18;
                        
                        if (ally.sword) {
                            ally.sword.rotation.z = -Math.PI / 3;
                            setTimeout(function() {
                                if (ally.sword) ally.sword.rotation.z = -0.3;
                            }, 220);
                        }
                        
                        if (ally.targetEnemy.health <= 0) {
                            killEnemy(ally.targetEnemy);
                            ally.targetEnemy = null;
                        }
                    }
                }
            }
            
            if (ally.attackCooldown > 0) {
                ally.attackCooldown--;
            }
        }

        function createVampire() {
            const vampire = new THREE.Group();
            
            const torsoGeometry = new THREE.CylinderGeometry(0.55, 0.75, 1.8, 14);
            const vampireMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a0a0a,
                shininess: 60
            });
            const torso = new THREE.Mesh(torsoGeometry, vampireMaterial);
            torso.position.y = 2.3;
            torso.castShadow = true;
            vampire.add(torso);
            
            const legGeometry = new THREE.CylinderGeometry(0.24, 0.27, 1.5, 12);
            const leftLeg = new THREE.Mesh(legGeometry, vampireMaterial);
            leftLeg.position.set(-0.3, 0.45, 0);
            leftLeg.castShadow = true;
            vampire.add(leftLeg);
            vampire.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeometry, vampireMaterial);
            rightLeg.position.set(0.3, 0.45, 0);
            rightLeg.castShadow = true;
            vampire.add(rightLeg);
            vampire.rightLeg = rightLeg;
            
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.22, 1.7, 12);
            const leftArm = new THREE.Mesh(armGeometry, vampireMaterial);
            leftArm.position.set(-0.85, 2.3, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            vampire.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, vampireMaterial);
            rightArm.position.set(0.85, 2.3, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            vampire.add(rightArm);
            vampire.rightArm = rightArm;
            
            const headGeometry = new THREE.SphereGeometry(0.47, 16, 16);
            const paleSkinMaterial = new THREE.MeshPhongMaterial({ color: 0xE8E8E8 });
            const head = new THREE.Mesh(headGeometry, paleSkinMaterial);
            head.position.y = 3.65;
            head.castShadow = true;
            vampire.add(head);
            
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                emissive: 0xFF0000
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15, 3.75, 0.45);
            vampire.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15, 3.75, 0.45);
            vampire.add(rightEye);
            
            const capeGeometry = new THREE.BoxGeometry(1.2, 2.0, 0.08);
            const capeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0a0a0a,
                side: THREE.DoubleSide
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 2.0, -0.4);
            cape.castShadow = true;
            vampire.add(cape);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 20;
            vampire.position.set(
                Math.cos(angle) * distance,
                0,
                Math.sin(angle) * distance
            );
            
            vampire.health = 30;
            vampire.speed = 0.08 + Math.random() * 0.04;
            vampire.attackCooldown = 0;
            vampire.isEnemy = true;
            vampire.walkCycle = 0;
            
            return vampire;
        }
        
        function createDraculaGeneral() {
            const dracula = createVampire();
            dracula.scale.set(1.4, 1.4, 1.4);
            
            const crownGeometry = new THREE.CylinderGeometry(0.4, 0.35, 0.45, 12);
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFD700,
                shininess: 130,
                emissive: 0x332200
            });
            const crown = new THREE.Mesh(crownGeometry, crownMaterial);
            crown.position.y = 3.0;
            crown.castShadow = true;
            dracula.add(crown);
            
            const auraGeometry = new THREE.RingGeometry(2, 3, 32);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xAA0000,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.1;
            dracula.add(aura);
            dracula.aura = aura;
            
            dracula.health = 200;
            dracula.maxHealth = 200;
            dracula.isLeader = true;
            
            return dracula;
        }

        function spawnEnemies() {
            // Don't spawn enemies in prayer-only chapters (Story Mode)
            if (gameState.mode === 'story') {
                const chapter = storyChapters[gameState.currentChapter];
                if (chapter && chapter.objective.type === 'prayers') {
                    return; // No enemies in prayer chapters
                }
            }
            
            if (gameState.enemies.length < 20) {
                // Spawn vampires in Gun Mode, regular enemies otherwise
                const enemy = (gameState.mode === 'gun') ? createVampire() : createEnemy();
                gameState.enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function spawnLeader() {
            // Don't spawn leaders in prayer-only chapters (Story Mode)
            if (gameState.mode === 'story') {
                const chapter = storyChapters[gameState.currentChapter];
                if (chapter && chapter.objective.type === 'prayers') {
                    return; // No leaders in prayer chapters
                }
            }
            
            const maxLeaders = (gameState.mode === 'alexander' || gameState.mode === 'gun') ? 2 : 2;
            if (gameState.leaders.length < maxLeaders && gameState.leadersDefeated < gameState.totalLeaders) {
                // Spawn Dracula in Gun Mode, regular leaders otherwise
                const leader = (gameState.mode === 'gun') ? createDraculaGeneral() : createEnemyLeader();
                gameState.leaders.push(leader);
                gameState.enemies.push(leader);
                scene.add(leader);
            }
        }

        let lastTime = Date.now();
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let spawnTimer = 0;
        let leaderSpawnTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameState.gameStarted || !player) {
                renderer.render(scene, camera);
                return;
            }
            
            const currentTime = Date.now();
            lastTime = currentTime;

            frameCount++;
            if (currentTime - lastFPSUpdate >= 1000) {
                document.getElementById('fpsValue').textContent = frameCount;
                frameCount = 0;
                lastFPSUpdate = currentTime;
            }

            const moveSpeed = 0.22;
            let isMoving = false;
            
            if (joystickActive) {
                const joyX = mobileControls.moveVector.x;
                const joyZ = mobileControls.moveVector.z;
                
                if (Math.abs(joyX) > 0.1 || Math.abs(joyZ) > 0.1) {
                    isMoving = true;
                    
                    const angle = Math.atan2(joyX, joyZ);
                    let direction = Math.round(angle / (Math.PI / 4));
                    if (direction < 0) direction += 8;
                    if (direction >= 8) direction = 0;
                    
                    const magnitude = Math.min(Math.sqrt(joyX * joyX + joyZ * joyZ), 1);
                    
                    // Calculate movement direction
                    const moveDir = {
                        x: Math.sin(angle) * magnitude,
                        z: Math.cos(angle) * magnitude
                    };
                    
                    // Apply collision-aware movement
                    const moved = applyCollisionAvoidance(player, moveDir, moveSpeed);
                    
                    if (moved) {
                        player.rotation.y = angle;
                        player.direction = direction;
                    } else {
                        // If blocked, stop walking animation
                        isMoving = false;
                    }
                }
            }

            if (isMoving) {
                player.walkCycle += 0.18;
                
                const legSwing = Math.sin(player.walkCycle) * 0.6;
                player.leftLeg.rotation.x = legSwing;
                player.rightLeg.rotation.x = -legSwing;
                player.rightArm.rotation.x = Math.sin(player.walkCycle) * 0.4;
                
                const bodyBob = Math.abs(Math.sin(player.walkCycle)) * 0.15;
                player.position.y = bodyBob;
                
                player.cape.rotation.x = Math.sin(player.walkCycle * 0.5) * 0.12;
            } else {
                player.leftLeg.rotation.x *= 0.9;
                player.rightLeg.rotation.x *= 0.9;
                player.rightArm.rotation.x *= 0.9;
                player.position.y *= 0.9;
                player.cape.rotation.x *= 0.9;
                
                const breathe = Math.sin(currentTime * 0.001) * 0.02;
                player.position.y = breathe;
            }

            player.position.x = Math.max(-110, Math.min(110, player.position.x));
            player.position.z = Math.max(-110, Math.min(110, player.position.z));

            if (player.glow && player.glowLight) {
                player.glow.material.opacity = 0.12 + Math.sin(currentTime * 0.002) * 0.08;
                player.glowLight.intensity = 0.6 + Math.sin(currentTime * 0.003) * 0.4;
            }

            gameState.enemies.forEach(updateEnemy);
            gameState.allies.forEach(updateAlly);

            spawnTimer++;
            if (spawnTimer > 120) {
                spawnTimer = 0;
                spawnEnemies();
            }
            
            // Spawn leaders every 30 seconds (1800 frames at 60fps)
            leaderSpawnTimer++;
            if (leaderSpawnTimer > 1800) {
                leaderSpawnTimer = 0;
                spawnLeader();
            }

            camera.position.x = player.position.x;
            camera.position.z = player.position.z + 28;
            camera.lookAt(player.position);

            gameState.special = Math.min(gameState.maxSpecial, gameState.special + 0.05);
            if (Math.random() < 0.01) {
                updateUI();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        renderer.render(scene, camera);
    </script>
</body>
</html>
